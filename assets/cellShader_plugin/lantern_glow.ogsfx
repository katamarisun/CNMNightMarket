
// transform object vertices to world-space:
uniform mat4 gWorldXf : World < string UIWidget="None"; >;

// transform object normals, tangents, & binormals to world-space:
uniform mat4 gWorldITXf : WorldInverseTranspose < string UIWidget="None"; >;

// transform object vertices to view space and project them in perspective:
uniform mat4 gWvpXf : WorldViewProjection < string UIWidget="None"; >;

// provide tranform from "view" or "eye" coords back to world-space:
uniform mat4 gViewIXf : ViewInverse < string UIWidget="None"; >;


/*** TWEAKABLES *********************************************/
uniform float cutoff
<
    string UIWidget = "slider";
    float UIMin = -4.0;
    float UIMax = 4.0;
    float UIStep = 0.01;
    string UIName = "Normal Cutoff";
    string UIGroup = "Lantern Colors";
> = 0.5;

uniform float softness
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Key Softness";
    string UIGroup = "Lantern Colors";
> = 1.0;

uniform vec4 middleColor
<
    string UIName = "Middle Color";
    string UIWidget = "Color";
    string UIGroup = "Lantern Colors";
> = {0.6, 0.6, 0.6, 1.0f};

uniform vec4 outerColor
<
    string UIName = "Outer Color";
    string UIWidget = "Color";
    string UIGroup = "Lantern Colors";
> = {0.5, 0.5, 0.5, 1.0f};


attribute appdata {
    vec3 Position    : POSITION;
    vec2 UV        : TEXCOORD0;
    vec3 Normal    : NORMAL;
    vec2 inmap1 : TEXCOORD0;
};

/* data passed from vertex shader to pixel shader */
attribute cellVertexOutput {
    vec3 WorldNormal    : TEXCOORD4;
    vec2 fUV : TEXCOORD1;
    vec3 WorldEyeVec    : TEXCOORD2;
    vec4 ObjPos    : TEXCOORD3;
    vec4 WorldPosition : TEXCOORD0;
};

/* data passed from vertex shader to pixel shader */
attribute cellPixelInput {
    vec3 WorldNormal    : TEXCOORD4;
    vec2 fUV : TEXCOORD1;
    vec3 WorldEyeVec    : TEXCOORD2;
    vec4 ObjPos    : TEXCOORD3;
    vec4 WorldPosition : TEXCOORD0;
};

/* data output by the fragment shader */
attribute pixelOut 
{
    vec4 colorOut:COLOR0;
}

GLSLShader VS
{
	void main(void)
	{
	    vec3 Nw = normalize((gWorldITXf * vec4(Normal,0.0)).xyz);
    	WorldNormal = Nw;
    	vec4 Po = vec4(Position.xyz,1);
    	vec3 Pw = (gWorldXf*Po).xyz;
    	WorldPosition = vec4(Pw.x, Pw.y, Pw.z, 1.0);
    	WorldEyeVec = normalize(gViewIXf[3].xyz - Pw);
    	vec4 hpos = gWvpXf * Po;
    	fUV = vec2(UV[0], 1.0-UV[1]);
    	ObjPos = Po;
    	vec4 OutUVs = vec4(inmap1.x, inmap1.y, 0.0, 0.0);
    	gl_Position = hpos;	
	}
}


GLSLShader FS
{

	float calc_alpha( float softness, float cutoff, float cos );
    float blendOverlay(float base, float blend);
    vec4 blendOverlay(vec4 base, vec4 blend);
    vec4 blendOverlay(vec4 base, vec4 blend, float opacity);

	void main(void)
	{
        colorOut = blendOverlay(base_color, gradient, base_color.r);
	}

	float calc_alpha( float softness, float cutoff, float cos )
	{
	    float lower_bound = cutoff - softness;
	    float upper_bound = cutoff + softness;
	    float result_alpha = 0;
	    if (cos < lower_bound) {
	        result_alpha = 0.0;
	    } else {
	        if (cos > upper_bound) {
	            result_alpha = 1.0;
	        } else {
	            result_alpha = ( cos - lower_bound ) / ( 2 * softness );
	        }
	    }
	    return result_alpha;
	}

    vec4 blendOverlay(vec4 base, vec4 blend, float opacity) {
        return (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));
    }

    vec4 blendOverlay(vec4 base, vec4 blend) {
        return vec4(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b), 1.0);
    }

    float blendOverlay(float base, float blend) {
        return base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));
    }
}

technique main
{
	pass light_color
	<
		string drawContext = "colorPass";
	>
	{
        VertexShader (in appdata, out cellVertexOutput) = VS;
        PixelShader (in cellVertexOutput, out pixelOut) = FS;
	}

}

