
// transform object vertices to world-space:
uniform mat4 gWorldXf : World < string UIWidget="None"; >;

// transform object normals, tangents, & binormals to world-space:
uniform mat4 gWorldITXf : WorldInverseTranspose < string UIWidget="None"; >;

// transform object vertices to view space and project them in perspective:
uniform mat4 gWvpXf : WorldViewProjection < string UIWidget="None"; >;

// provide tranform from "view" or "eye" coords back to world-space:
uniform mat4 gViewIXf : ViewInverse < string UIWidget="None"; >;


/*** TWEAKABLES *********************************************/

uniform bool use_presence
<
    string UIName = "Use Presence Map";
    string UIGroup = "Appearance";
>
    = 0.0;


uniform texture2D presence_map <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Presence Map";
    string UIGroup = "Appearance";
>;

uniform sampler2D presence_sampler
    = sampler_state {
    Texture = <presence_map>;
};

uniform float masterOpacity
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Master Opacity";
    string UIGroup = "Appearance";
> = 1.0;

uniform bool use_opacity
<
    string UIName = "Use Opacity Map";
    string UIGroup = "Appearance";
> = 0.0;


uniform texture2D opacity_map <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Opacity Map";
    string UIGroup = "Appearance";
>;

uniform sampler2D opacity_sampler
    = sampler_state {
    Texture = <opacity_map>;
};

uniform float cutoff
<
    string UIWidget = "slider";
    float UIMin = -4.0;
    float UIMax = 4.0;
    float UIStep = 0.01;
    string UIName = "Normal Cutoff";
    string UIGroup = "Lantern Colors";
> = 0.911;

uniform float softness
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Edge Softness";
    string UIGroup = "Lantern Colors";
> = 0.031;

uniform float eyeDirFudge
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Fudge Eye Direction";
    string UIGroup = "Fudge Factors";
> = 0.1;

uniform float darkenFudge
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Fudge Darken";
    string UIGroup = "Fudge Factors";
> = 0.17;

uniform float fudgeHotSpot
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Cuttoff to See HotSpot";
    string UIGroup = "Fudge Factors";
> = 0.1;

uniform float brightSpot
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 300.0;
    float UIStep = 0.01;
    string UIName = "Bright Spot Power";
    string UIGroup = "Lantern Colors";
> = 83.297;

uniform vec4 hotColor
<
    string UIName = "Hotspot Color";
    string UIWidget = "Color";
    string UIGroup = "Lantern Colors";
> = {1.0, 0.84, 0.35, 1.0f};

uniform vec4 middleColor
<
    string UIName = "Middle Color";
    string UIWidget = "Color";
    string UIGroup = "Lantern Colors";
> = {0.82, 0.54, 0.0, 1.0f};

uniform vec4 outerColor
<
    string UIName = "Outer Color";
    string UIWidget = "Color";
    string UIGroup = "Lantern Colors";
> = {0.58, 0.0, 0.0, 1.0f};


// Defining textures is only necessary in OGSFX since it 
// can be assigned automatically to a sampler
uniform texture2D diffuseColorTex <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Diffuse Texture";
    string UIGroup = "Base Color";
>;

uniform sampler2D diffuseSampler
    = sampler_state {
    Texture = <diffuseColorTex>;
};


attribute appdata {
    vec3 Position    : POSITION;
    vec2 UV        : TEXCOORD0;
    vec3 Normal    : NORMAL;
};

/* data passed from vertex shader to pixel shader */
attribute cellVertexOutput {
    vec3 WorldNormal    : TEXCOORD1;
    vec3 WorldEyeVec    : TEXCOORD2;
    vec4 ObjPos    : TEXCOORD3;
    vec2 fUV : TEXCOORD4;
    vec3 fPos : TEXCOORD5;
};

/* data passed from vertex shader to pixel shader */
attribute cellPixelInput {
    vec3 WorldNormal    : TEXCOORD1;
    vec3 WorldEyeVec    : TEXCOORD2;
    vec4 ObjPos    : TEXCOORD3;
    vec2 fUV : TEXCOORD4;
    vec3 fPos : TEXCOORD5;
};

/* data output by the fragment shader */
attribute pixelOut 
{
    vec4 colorOut:COLOR0;
}

GLSLShader VS
{
	void main(void)
	{
        vec3 Nw = normalize((gWorldITXf * vec4(Normal,0.0)).xyz);
        WorldNormal = Nw;
        vec4 Po = vec4(Position.xyz,1);
        vec3 Pw = (gWorldXf*Po).xyz;
        WorldEyeVec = normalize(gViewIXf[3].xyz - Pw);
        fUV = vec2(UV.x, 1.0-UV.y);
        fPos = Position;
        gl_Position = gWvpXf * Po;
	}
}


GLSLShader FS
{

	float calc_alpha( float softness, float cutoff, float cos );
    float blendOverlay(float base, float blend);
    vec4 blendOverlay(vec4 base, vec4 blend);
    vec4 blendOverlay(vec4 base, vec4 blend, float opacity);

	void main(void)
	{
        vec4 base_color = texture2D(diffuseSampler, fUV) - vec4(darkenFudge);
		float cos = abs(dot( normalize(WorldNormal), normalize(WorldEyeVec - vec3(0.0, eyeDirFudge, 0.0)) ));
		float alphaOuter = calc_alpha( softness, cutoff, cos );
        float alphaMiddle = calc_alpha( softness, cutoff / 2, cos );
		vec4 gradientOuter = alphaOuter * outerColor;
        vec4 gradientMiddle = alphaMiddle * middleColor;

        float dodgeLerpFactor = 1.0;
        if (base_color.r < fudgeHotSpot) {
            dodgeLerpFactor = base_color.r;
        }
        vec4 colorDodge = lerp( base_color, saturate(hotColor + base_color), dodgeLerpFactor);

        vec4 colorOverlay = blendOverlay(base_color, gradientOuter, base_color.r);
        colorOverlay = blendOverlay(colorOverlay, gradientMiddle, base_color.r);

        colorOut = lerp(colorOverlay, colorDodge, pow(cos, brightSpot));
        colorOut = vec4(vec3(colorOut), masterOpacity);
	}

	float calc_alpha( float softness, float cutoff, float cos )
	{
	    float lower_bound = cutoff - softness;
	    float upper_bound = cutoff + softness;
	    float result_alpha = 0;
	    if (cos < lower_bound) {
	        result_alpha = 0.0;
	    } else {
	        if (cos > upper_bound) {
	            result_alpha = 1.0;
	        } else {
	            result_alpha = ( cos - lower_bound ) / ( 2 * softness );
	        }
	    }
	    return result_alpha;
	}

    vec4 blendOverlay(vec4 base, vec4 blend, float opacity) {
        return (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));
    }

    vec4 blendOverlay(vec4 base, vec4 blend) {
        return vec4(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b), 1.0);
    }

    float blendOverlay(float base, float blend) {
        return base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));
    }
}

technique main
{
	pass light_color
	<
		string drawContext = "colorPass";
	>
	{
        VertexShader (in appdata, out cellVertexOutput) = VS;
        PixelShader (in cellVertexOutput, out pixelOut) = FS;
	}

}

