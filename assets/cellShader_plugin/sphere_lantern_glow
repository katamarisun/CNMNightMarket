
// transform object vertices to world-space:
uniform mat4 gWorldXf : World < string UIWidget="None"; >;

// transform object normals, tangents, & binormals to world-space:
uniform mat4 gWorldITXf : WorldInverseTranspose < string UIWidget="None"; >;

// transform object vertices to view space and project them in perspective:
uniform mat4 gWvpXf : WorldViewProjection < string UIWidget="None"; >;

// provide tranform from "view" or "eye" coords back to world-space:
uniform mat4 gViewIXf : ViewInverse < string UIWidget="None"; >;


/*** TWEAKABLES *********************************************/

uniform vec4 middle_color
<
    string UIName = "Middle Color";
    string UIWidget = "Color";
> = {0.5, 0.5, 0.5, 1.0f};

uniform vec4 outer_color
<
    string UIName = "Outer Color";
    string UIWidget = "Color";
> = {0.5, 0.5, 0.5, 1.0f};

attribute appdata {
    vec3 Position    : POSITION;
    vec2 UV        : TEXCOORD0;
    vec3 Normal    : NORMAL;
    vec2 inmap1 : TEXCOORD0;
};

/* data passed from vertex shader to pixel shader */
attribute cellVertexOutput {
    vec3 WorldNormal    : TEXCOORD4;
    vec2 fUV : TEXCOORD1;
    vec3 WorldEyeVec    : TEXCOORD2;
    vec4 ObjPos    : TEXCOORD3;
    vec4 WorldPosition : TEXCOORD0;
};

/* data passed from vertex shader to pixel shader */
attribute cellPixelInput {
    vec3 WorldNormal    : TEXCOORD4;
    vec2 fUV : TEXCOORD1;
    vec3 WorldEyeVec    : TEXCOORD2;
    vec4 ObjPos    : TEXCOORD3;
    vec4 WorldPosition : TEXCOORD0;
};

/* data output by the fragment shader */
attribute pixelOut 
{
    vec4 colorOut:COLOR0;
}

GLSLShader VS
{
	void main(void)
	{
	    vec3 Nw = normalize((gWorldITXf * vec4(Normal,0.0)).xyz);
    	WorldNormal = Nw;
    	vec4 Po = vec4(Position.xyz,1);
    	vec3 Pw = (gWorldXf*Po).xyz;
    	WorldPosition = vec4(Pw.x, Pw.y, Pw.z, 1.0);
    	WorldEyeVec = normalize(gViewIXf[3].xyz - Pw);
    	vec4 hpos = gWvpXf * Po;
    	fUV = vec2(UV[0], 1.0-UV[1]);
    	ObjPos = Po;
    	vec4 OutUVs = vec4(inmap1.x, inmap1.y, 0.0, 0.0);
    	gl_Position = hpos;	
	}
}


GLSLShader FS
{
	void main(void)
	{
		float cos = dot( normalize(WorldNormal), normalize(WorldEyeVec));
		colorOut = cos * (middle_color) + (1 - cos) * (outer_color);
	}
}

technique main
{
	pass P1
	<
		string drawContext = "colorPass";
	>
	{
        VertexShader (in appdata, out cellVertexOutput) = VS;
        PixelShader (in cellVertexOutput, out pixelOut) = FS;
	}

}