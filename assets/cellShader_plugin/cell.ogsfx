//**********
//	This skeleton OGSFX file illustrates one potential way of
//	dealing with GLSL files that are to be shared between a 
//	pure OpenGL application and the glslShader:
//

// Tell included shaders to use OGSFX semantics and streams:
#define OGSFX 1

//**********
//	Uniform parameter handling:
//
//	Loads the uniforms from all shader stage files
//

#define HIDE_OGSFX_UNIFORMS 0
#define HIDE_OGSFX_STREAMS 1
#define HIDE_OGSFX_CODE 1

#include "cell.glslv"
#include "cell.glslf"

//**********
//	Input stream handling:
//
//	Loads the attribute streams from all shader stage files
//

#define HIDE_OGSFX_UNIFORMS 1
#define HIDE_OGSFX_STREAMS 0
#define HIDE_OGSFX_CODE 1

#include "cell.glslv"
#include "cell.glslf"

//**********
//	Code handling:
//
//	We need to load the vertex stage and fragment stage in two
//	different GLSLShader blocks in order to specify them in the
//	technique definition below:
//

#define HIDE_OGSFX_UNIFORMS 1
#define HIDE_OGSFX_STREAMS 1
#define HIDE_OGSFX_CODE 0

// Vertex shader.
GLSLShader VS
{
#include "cell.glslv"
}

// Fragment shader.
GLSLShader FS
{
#include "cell.glslf"
}


uniform vec2 ShadowFilterTaps[10] < string UIWidget = "None"; > = {{-0.84052, -0.073954}, {-0.326235, -0.40583}, {-0.698464, 0.457259}, {-0.203356, 0.620585}, {0.96345, -0.194353}, {0.473434, -0.480026}, {0.519454, 0.767034}, {0.185461, -0.894523}, {0.507351, 0.064963}, {-0.321932, 0.595435}};


// ----------------------------------- Per Frame --------------------------------------
uniform mat4 viewI : ViewInverse < string UIWidget = "None"; >;

uniform mat4 viewPrj : ViewProjection < string UIWidget = "None"; >;

uniform bool MayaHwFogEnabled : HardwareFogEnabled < string UIWidget = "None"; > = false; 
uniform int MayaHwFogMode : HardwareFogMode < string UIWidget = "None"; > = 0; 
uniform float MayaHwFogStart : HardwareFogStart < string UIWidget = "None"; > = 0.0; 
uniform float MayaHwFogEnd : HardwareFogEnd < string UIWidget = "None"; > = 100.0; 
uniform float MayaHwFogDensity : HardwareFogDensity < string UIWidget = "None"; > = 0.1; 
uniform vec4 MayaHwFogColor : HardwareFogColor < string UIWidget = "None"; > = { 0.5, 0.5, 0.5, 1.0 }; 
uniform float DepthRange : LightRange < string UIWidget = "None"; > = 100000.0;

uniform mat4 view : View < string UIWidget = "None"; >;

// ---------------------------------------- Textures -----------------------------------------
uniform texture2D SurfaceMask
<
	string ResourceName = "";
	string UIName = "Surface Mask";
	string ResourceType = "2D";
	string UIWidget = "FilePicker";
	string UIGroup = "Surface";
>;

uniform sampler2D SurfaceMaskSampler = sampler_state 
{
	Texture = <SurfaceMask>;
	TEXTURE_MIN_FILTER = LINEAR;
	TEXTURE_MAG_FILTER = LINEAR;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};


uniform float SurfaceMaskCutoff
<
	float UIMin = 0.0;
	float UISoftMin = 0.0;
	float UIMax = 99.0;
	float UISoftMax = 99.0;
	float UIStep = 0.01;
	string UIName = "Surface Mask Cutoff";
	string UIWidget = "Slider";
	string UIGroup = "Surface";
> = 0.0;

// --------------------------------------- Per Object -----------------------------------------
uniform mat4 world : World < string UIWidget = "None"; >;

uniform float BBoxExtraScale : BoundingBoxExtraScale
<
	float UISoftMin = 1.0;
	float UISoftMax = 99.0;
	float UIStep = 0.1;
	string UIName = "Bounding Box Extra Scale";
	string UIWidget = "Slider";
	string UIGroup = "Tessellation and Displacement";
	int UIOrder = 808;
> = 1.0;

uniform int ClampDynamicLights
<
	float UIMin = 0;
	float UISoftMin = 0;
	float UIMax = 99;
	float UISoftMax = 99;
	float UIStep = 1;
	string UIName = "Clamp Dynamic Lights";
	string UIWidget = "Slider";
	string UIGroup = "Lighting";
> = 99;

uniform mat4 shadowViewPrj : ViewProjection < string UIWidget = "None"; >;

uniform bool IsSwatchRender : MayaSwatchRender <string UIWidget = "None"; > = false;


uniform int KeyLightType : LIGHTTYPE
<
	string UIName = "Key Type";
	float UIMin = 0;
	float UIMax = 5;
	float UIStep = 1;
	string UIWidget = "None";
	string Object = "Key";
> = 3;

uniform vec3 KeyLightColor : LIGHTCOLOR
<
	string UIName = "Key Color";
	string UIWidget = "ColorPicker";
	string Object = "Key";
> = {1.0, 1.0, 1.0};

uniform float KeyLightIntensity : LIGHTINTENSITY
<
	string UIName = "Key Intensity";
	float UIMin = 0;
	float UIStep = 0.1;
	string Object = "Key";
> = 1.0;

uniform vec3 KeyLightPos : POSITION
<
	string UIName = "Key Position";
	string Space = "World";
	string Object = "Key";
> = {1.0, 1.0, 1.0};

uniform vec3 KeyLightDir : DIRECTION
<
	string UIName = "Key Direction";
	string Space = "World";
	string Object = "Key";
> = {0.0, -1.0, 0.0};

uniform float KeyLightAttenuation : DECAYRATE
<
	string UIName = "Key Decay";
	float UIMin = 0;
	float UIStep = 1;
	string Object = "Key";
> = 0.0;

uniform float KeyLightConeAngle : HOTSPOT
<
	string UIName = "Key Cone Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Space = "World";
	string Object = "Key";
> = 0.46;

uniform float KeyLightFalloff : FALLOFF
<
	string UIName = "Key Penumbra Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Object = "Key";
> = 0.7;

uniform bool KeyLightShadowOn : SHADOWFLAG
<
	string UIName = "Key Casts Shadow";
	string Object = "Key";
> = true;

uniform mat4 KeyLightViewPrj : SHADOWMAPMATRIX
<
	string Object = "Key";
	string UIName = "Key Matrix";
	string UIWidget = "None";
>;

uniform vec3 KeyLightShadowColor : SHADOWCOLOR
<
	string UIName = "Key Shadow Color";
	string Object = "Key";
> = {0, 0, 0};

uniform texture2D KeyLightShadowMap : SHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "2D";
	string UIWidget = "None";
	string Object = "Key";
	string UIName = "KeyLightShadowMap";
>;

uniform sampler2D KeyLightShadowMapSampler = sampler_state 
{
	Texture = <KeyLightShadowMap>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};

uniform textureCube PointKeyLightShadowMap : POINTLIGHTSHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "Cube";
	string UIWidget = "None";
	string Object = "Key";
	string UIName = "PointKeyShadowMap";
>;

uniform samplerCube PointKeyLightShadowMapSampler = sampler_state 
{
	Texture = <PointKeyLightShadowMap>;
	TEXTURE_MIN_FILTER = LINEAR_MIPMAP_LINEAR;
	TEXTURE_MAG_FILTER = LINEAR;
	TEXTURE_WRAP_S = MIRRORED_REPEAT;
	TEXTURE_WRAP_T = MIRRORED_REPEAT;
	TEXTURE_WRAP_R = MIRRORED_REPEAT;
};

uniform int BounceLightType : LIGHTTYPE
<
	string UIName = "Bounce Type";
	float UIMin = 0;
	float UIMax = 5;
	float UIStep = 1;
	string UIWidget = "None";
	string Object = "Bounce";
> = 3;

uniform vec3 BounceLightColor : LIGHTCOLOR
<
	string UIName = "Bounce Color";
	string UIWidget = "ColorPicker";
	string Object = "Bounce";
> = {1.0, 1.0, 1.0};

uniform float BounceLightIntensity : LIGHTINTENSITY
<
	string UIName = "Bounce Intensity";
	float UIMin = 0;
	float UIStep = 0.1;
	string Object = "Bounce";
> = 1.0;

uniform vec3 BounceLightPos : POSITION
<
	string UIName = "Bounce Position";
	string Space = "World";
	string Object = "Bounce";
> = {1.0, 1.0, 1.0};

uniform vec3 BounceLightDir : DIRECTION
<
	string UIName = "Bounce Direction";
	string Space = "World";
	string Object = "Bounce";
> = {0.0, -1.0, 0.0};

uniform float BounceLightAttenuation : DECAYRATE
<
	string UIName = "Bounce Decay";
	float UIMin = 0;
	float UIStep = 1;
	string Object = "Bounce";
> = 0.0;

uniform float BounceLightConeAngle : HOTSPOT
<
	string UIName = "Bounce Cone Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Space = "World";
	string Object = "Bounce";
> = 0.46;

uniform float BounceLightFalloff : FALLOFF
<
	string UIName = "Bounce Penumbra Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Object = "Bounce";
> = 0.7;

uniform bool BounceLightShadowOn : SHADOWFLAG
<
	string UIName = "Bounce Casts Shadow";
	string Object = "Bounce";
> = true;

uniform mat4 BounceLightViewPrj : SHADOWMAPMATRIX
<
	string Object = "Bounce";
	string UIName = "Bounce Matrix";
	string UIWidget = "None";
>;

uniform vec3 BounceLightShadowColor : SHADOWCOLOR
<
	string UIName = "Light 0 Shadow Color";
	string Object = "Light 0";
> = {0, 0, 0};

uniform texture2D BounceLightShadowMap : SHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "2D";
	string UIWidget = "None";
	string Object = "Bounce";
	string UIName = "BounceLightShadowMap";
>;

uniform sampler2D BounceLightShadowMapSampler = sampler_state 
{
	Texture = <BounceLightShadowMap>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};

uniform textureCube PointBounceLightShadowMap : POINTLIGHTSHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "Cube";
	string UIWidget = "None";
	string Object = "Key";
	string UIName = "PointBounceShadowMap";
>;

uniform samplerCube PointBounceLightShadowMapSampler = sampler_state 
{
	Texture = <PointBounceLightShadowMap>;
	TEXTURE_MIN_FILTER = LINEAR_MIPMAP_LINEAR;
	TEXTURE_MAG_FILTER = LINEAR;
	TEXTURE_WRAP_S = MIRRORED_REPEAT;
	TEXTURE_WRAP_T = MIRRORED_REPEAT;
	TEXTURE_WRAP_R = MIRRORED_REPEAT;
};

uniform int RimLightType : LIGHTTYPE
<
	string UIName = "Rim Type";
	float UIMin = 0;
	float UIMax = 5;
	float UIStep = 1;
	string UIWidget = "None";
	string Object = "Rim";
> = 3;

uniform vec3 RimLightColor : LIGHTCOLOR
<
	string UIName = "Rim Color";
	string UIWidget = "ColorPicker";
	string Object = "Rim";
> = {1.0, 1.0, 1.0};

uniform float RimLightIntensity : LIGHTINTENSITY
<
	string UIName = "Rim Intensity";
	float UIMin = 0;
	float UIStep = 0.1;
	string Object = "Rim";
> = 1.0;

uniform vec3 RimLightPos : POSITION
<
	string UIName = "Rim Position";
	string Space = "World";
	string Object = "Rim";
> = {1.0, 1.0, 1.0};

uniform vec3 RimLightDir : DIRECTION
<
	string UIName = "Rim Direction";
	string Space = "World";
	string Object = "Rim";
> = {0.0, -1.0, 0.0};

uniform float RimLightAttenuation : DECAYRATE
<
	string UIName = "Rim Decay";
	float UIMin = 0;
	float UIStep = 1;
	string Object = "Rim";
> = 0.0;

uniform float RimLightConeAngle : HOTSPOT
<
	string UIName = "Rim Cone Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Space = "World";
	string Object = "Rim";
> = 0.46;

uniform float RimLightFalloff : FALLOFF
<
	string UIName = "Rim Penumbra Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Object = "Rim";
> = 0.7;

uniform bool RimLightShadowOn : SHADOWFLAG
<
	string UIName = "Rim Casts Shadow";
	string Object = "Rim";
> = true;

uniform mat4 RimLightViewPrj : SHADOWMAPMATRIX
<
	string Object = "Rim";
	string UIName = "Rim Matrix";
	string UIWidget = "None";
>;

uniform vec3 RimLightShadowColor : SHADOWCOLOR
<
	string UIName = "Rim Shadow Color";
	string Object = "Rim";
> = {0, 0, 0};

uniform texture2D RimLightShadowMap : SHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "2D";
	string UIWidget = "None";
	string Object = "Light 0";
	string UIName = "RimLightShadowMap";
>;

uniform sampler2D RimLightShadowMapSampler = sampler_state 
{
	Texture = <RimLightShadowMap>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};

uniform textureCube PointRimLightShadowMap : POINTLIGHTSHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "Cube";
	string UIWidget = "None";
	string Object = "Key";
	string UIName = "PointRimShadowMap";
>;

uniform samplerCube PointRimLightShadowMapSampler = sampler_state 
{
	Texture = <PointRimLightShadowMap>;
	TEXTURE_MIN_FILTER = LINEAR_MIPMAP_LINEAR;
	TEXTURE_MAG_FILTER = LINEAR;
	TEXTURE_WRAP_S = MIRRORED_REPEAT;
	TEXTURE_WRAP_T = MIRRORED_REPEAT;
	TEXTURE_WRAP_R = MIRRORED_REPEAT;
};

GLSLShader PixelShader_Funcs
{
	int GetLightType(int ActiveLightIndex) 
	{ 
		if (ActiveLightIndex == 0) 
			return KeyLightType; 
		else if (ActiveLightIndex == 1) 
			return BounceLightType; 
		else 
			return RimLightType; 
	}

	vec3 GetLightColor(int ActiveLightIndex) 
	{ 
		if (ActiveLightIndex == 0) 
			return KeyLightColor; 
		else if (ActiveLightIndex == 1) 
			return BounceLightColor; 
		else 
			return RimLightColor; 
	}

	float GetLightIntensity(int ActiveLightIndex) 
	{ 
		if (ActiveLightIndex == 0) 
			return KeyLightIntensity; 
		else if (ActiveLightIndex == 1) 
			return BounceLightIntensity; 
		else 
			return RimLightIntensity; 
	}

	vec3 GetLightPos(int ActiveLightIndex) 
	{ 
		if (ActiveLightIndex == 0) 
			return KeyLightPos; 
		else if (ActiveLightIndex == 1) 
			return BounceLightPos; 
		else 
			return RimLightPos; 
	}

	vec3 GetLightDir(int ActiveLightIndex) 
	{ 
		if (ActiveLightIndex == 0) 
			return KeyLightDir; 
		else if (ActiveLightIndex == 1) 
			return BounceLightDir; 
		else 
			return RimLightDir; 
	}

	float GetLightAttenuation(int ActiveLightIndex) 
	{ 
		if (ActiveLightIndex == 0) 
			return KeyLightAttenuation; 
		else if (ActiveLightIndex == 1) 
			return BounceLightAttenuation; 
		else 
			return RimLightAttenuation; 
	}

	float GetLightConeAngle(int ActiveLightIndex) 
	{ 
		if (ActiveLightIndex == 0) 
			return KeyLightConeAngle; 
		else if (ActiveLightIndex == 1) 
			return BounceLightConeAngle; 
		else 
			return RimLightConeAngle; 
	}

	float GetLightFalloff(int ActiveLightIndex) 
	{ 
		if (ActiveLightIndex == 0) 
			return KeyLightFalloff; 
		else if (ActiveLightIndex == 1) 
			return BounceLightFalloff; 
		else 
			return RimLightFalloff; 
	}

	bool GetLightShadowOn(int ActiveLightIndex) 
	{ 
		if (ActiveLightIndex == 0) 
			return KeyLightShadowOn; 
		else if (ActiveLightIndex == 1) 
			return BounceLightShadowOn; 
		else 
			return RimLightShadowOn; 
	}

	mat4 GetLightViewPrj(int ActiveLightIndex) 
	{ 
		if (ActiveLightIndex == 0) 
			return KeyLightViewPrj; 
		else if (ActiveLightIndex == 1) 
			return BounceLightViewPrj; 
		else 
			return RimLightViewPrj; 
	}

	vec4 SampleFromShadowMap( int ActiveLightIndex, vec2 UVs) 
	{ 
		if (ActiveLightIndex == 0) 
			return textureLod(KeyLightShadowMapSampler, UVs, 0); 
		else if (ActiveLightIndex == 1) 
			return textureLod(BounceLightShadowMapSampler, UVs, 0); 
		else 
			return textureLod(RimLightShadowMapSampler, UVs, 0); 		
	}

	vec4 SampleFromPointLightShadowMap( int ActiveLightIndex, vec3 dir) 
	{ 
		if (ActiveLightIndex == 0) 
			return textureLod(PointKeyLightShadowMapSampler, dir, 0); 
		else if (ActiveLightIndex == 1) 
			return textureLod(PointBounceLightShadowMapSampler, dir, 0); 
		else 
			return textureLod(PointRimLightShadowMapSampler, dir, 0);
	}

	vec3 GetLightShadowColor(int ActiveLightIndex) 
	{ 
		if (ActiveLightIndex == 0) 
			return KeyLightShadowColor; 
		else if (ActiveLightIndex == 1) 
			return BounceLightShadowColor; 
		else 
			return RimLightShadowColor; 
	}


	// -------------------------------------- ExpandRangeFunction --------------------------------------
	struct ExpandRangeOutput
	{
		vec3 ExpandedVector;
	};

	ExpandRangeOutput ExpandRangeFunction(vec3 Vector)
	{
		ExpandRangeOutput OUT;

		vec3 NormalMap = (2.0 * Vector);
		vec3 NormalMap2083 = (NormalMap - 1.0);
		OUT.ExpandedVector = NormalMap2083;

		return OUT;
	}

	// -------------------------------------- TangentWorldConvertFunction --------------------------------------
	struct TangentWorldConvertOutput
	{
		vec3 Vector;
	};

	TangentWorldConvertOutput TangentWorldConvertFunction(float TangentDirection, vec3 Normal, vec3 Tangent, vec3 Vector)
	{
		TangentWorldConvertOutput OUT;

		vec3 Bn = (TangentDirection * cross(Normal, Tangent));
		mat3 toWorld = mat3(Tangent, Bn, Normal);
		vec3 TangentToWorld = (toWorld * Vector);
		OUT.Vector = TangentToWorld;

		return OUT;
	}

	// -------------------------------------- AmbientLightFunction --------------------------------------
	struct AmbientLightOutput
	{
		vec3 LightColor;
	};

	AmbientLightOutput AmbientLightFunction(int ActiveLightIndex, vec3 AlbedoColor, vec3 LightColor, float LightIntensity)
	{
		AmbientLightOutput OUT;

		vec3 MulOp = ((LightColor * AlbedoColor) * LightIntensity);
		OUT.LightColor = MulOp;

		return OUT;
	}

	// -------------------------------------- GetLightVectorFunction --------------------------------------
	struct GetLightVectorOutput
	{
		vec3 Result;
	};

	GetLightVectorOutput GetLightVectorFunction(int ActiveLightIndex, vec3 LightPosition, vec3 VertexWorldPosition, int LightType, vec3 LightDirection)
	{
		GetLightVectorOutput OUT;

		bool IsDirectionalLight = (LightType == 4);
		vec3 LerpOp = mix((LightPosition - VertexWorldPosition), -(LightDirection), float(IsDirectionalLight));
		OUT.Result = LerpOp;

		return OUT;
	}

	// -------------------------------------- TranslucencyFunction --------------------------------------
	struct TranslucencyOutput
	{
		vec3 Translucency;
	};

	TranslucencyOutput TranslucencyFunction(int ActiveLightIndex, vec3 Normal, vec3 LightVector, float Distortion, vec3 CameraVector, float Power, float LightScale, float Minimum, vec3 ObjectThickness, vec3 AlbedoColor)
	{
		TranslucencyOutput OUT;

		vec3 AddOp = (LightVector + (Distortion * Normal));
		float DotOp = dot(CameraVector, -(AddOp));
		float PowOp = pow(clamp(DotOp, 0.0, 1.0), Power);
		float AddOp333 = ((LightScale * PowOp) + Minimum);
		vec3 MulOp = (AlbedoColor * (ObjectThickness * AddOp333));
		OUT.Translucency = MulOp;

		return OUT;
	}

	// -------------------------------------- LambertDiffuseFunction --------------------------------------
	struct LambertDiffuseOutput
	{
		vec3 Color;
	};

	LambertDiffuseOutput LambertDiffuseFunction(int ActiveLightIndex, vec3 AlbedoColor, vec3 Normal, vec3 LightVector)
	{
		LambertDiffuseOutput OUT;

		float SatOp = clamp(dot(Normal, LightVector), 0.0, 1.0);
		vec3 Diffuse = (SatOp * AlbedoColor);
		OUT.Color = Diffuse;

		return OUT;
	}

	// -------------------------------------- LightDecayFunction --------------------------------------
	struct LightDecayOutput
	{
		float Attenuation;
	};

	LightDecayOutput LightDecayFunction(int ActiveLightIndex, vec3 LightVectorUN, float Attenuation)
	{
		LightDecayOutput OUT;

		bool IsAttenuationUsed = (Attenuation > 0.001);
		float DecayContribution116 = 0.0;
		if (IsAttenuationUsed)
		{
			float PowOp = pow(length(LightVectorUN), Attenuation);
			float DivOp = (1.0 / PowOp);
			DecayContribution116 = DivOp;
		}
		else
		{
			DecayContribution116 = 1.0;
		}
		OUT.Attenuation = DecayContribution116;

		return OUT;
	}

	// -------------------------------------- LightConeAngleFunction --------------------------------------
	struct LightConeAngleOutput
	{
		float ConeAngle;
	};

	LightConeAngleOutput LightConeAngleFunction(int ActiveLightIndex, vec3 LightVector, vec3 LightDirection, float ConeAngle, float ConeFalloff)
	{
		LightConeAngleOutput OUT;

		float CosOp = cos(max(ConeFalloff, ConeAngle));
		float DotOp = dot(LightVector, -(LightDirection));
		float SmoothStepOp = smoothstep(CosOp, cos(ConeAngle), DotOp);
		OUT.ConeAngle = SmoothStepOp;

		return OUT;
	}

	// -------------------------------------- ShadowMapFunction --------------------------------------
	struct ShadowMapOutput
	{
		float LightGain;
	};

	ShadowMapOutput ShadowMapFunction(int ActiveLightIndex, int lightType, mat4 LightViewPrj, float ShadowMapBias, vec3 VertexWorldPosition)
	{
		ShadowMapOutput OUT;

		if(lightType == 3) {
			OUT.LightGain = 1.0;

			float shadow = 1.0f;
			vec3 lightPos = GetLightPos(ActiveLightIndex);
			vec3 lookup = VertexWorldPosition - lightPos;
			float Distance = length(lookup);
			vec3 normalizeLookup = normalize(lookup);
			vec4 sampleColor = SampleFromPointLightShadowMap(ActiveLightIndex, normalizeLookup);

			float SampledDistance = sampleColor.r * DepthRange;
			if (Distance <= SampledDistance + ShadowMapBias*Distance) {
				shadow = 1.0f;
			} else {
				shadow = 0.0f;
			}

			OUT.LightGain = shadow;
		
		} else {
			float IfElseOp199 = 0.0;
			vec4 VectorConstruct = vec4(VertexWorldPosition.x, VertexWorldPosition.y, VertexWorldPosition.z, 1.0);
			vec4 MulOp = (LightViewPrj * VectorConstruct);
			vec3 DivOp = (MulOp.xyz / MulOp.w);
			if (DivOp.x > -1.0 && DivOp.x < 1.0 && DivOp.y > -1.0 && DivOp.y < 1.0 && DivOp.z > 0.0 && DivOp.z < 1.0)
			{
				float Val = 0.5;
				vec2 AddOp = ((Val * DivOp.xy) + Val);
				float SubOp = (DivOp.z - (ShadowMapBias / MulOp.w));
				float ShadowTotal = 0.0;
				for(int i=0; i<10; i+=1)
				{
					vec2 MulOp239 = (0.0009 * ShadowFilterTaps[i]);
					vec4 Sampler = SampleFromShadowMap(ActiveLightIndex, (AddOp + MulOp239));
					float IfElseOp193 = ((SubOp - Sampler.x) >= 0.0) ? (0.0) : (0.1);
					ShadowTotal += IfElseOp193;
				}
				IfElseOp199 = ShadowTotal;
			}
			else
			{
				IfElseOp199 = 1.0;
			}
			OUT.LightGain = IfElseOp199;
		}
		return OUT;
	}

	// -------------------------------------- LightContributionFunction --------------------------------------
	struct LightContributionOutput
	{
		vec3 Light;
	};

	LightContributionOutput LightContributionFunction(int ActiveLightIndex, vec3 VertexWorldPosition, vec3 LightVectorUN)
	{
		LightContributionOutput OUT;

		float _LightIntensity = GetLightIntensity(ActiveLightIndex);
		int _LightType = GetLightType(ActiveLightIndex);
		bool IsDirectionalLight = (_LightType == 4);
		float DecayMul162 = 0.0;
		if (IsDirectionalLight)
		{
			DecayMul162 = 1.0;
		}
		else
		{
			float _LightAttenuation = GetLightAttenuation(ActiveLightIndex);
			LightDecayOutput LightDecay110 = LightDecayFunction(ActiveLightIndex, LightVectorUN, _LightAttenuation);
			DecayMul162 = LightDecay110.Attenuation;
		}
		bool IsSpotLight = (_LightType == 2);
		float ConeMul164 = 1.0;
		if (IsSpotLight)
		{
			vec3 NormOp = normalize(LightVectorUN);
			vec3 _LightDir = GetLightDir(ActiveLightIndex);
			float _LightConeAngle = GetLightConeAngle(ActiveLightIndex);
			float _LightFalloff = GetLightFalloff(ActiveLightIndex);
			LightConeAngleOutput LightConeAngle52 = LightConeAngleFunction(ActiveLightIndex, NormOp, _LightDir, _LightConeAngle, _LightFalloff);
			ConeMul164 = LightConeAngle52.ConeAngle;
		}
		bool _LightShadowOn = GetLightShadowOn(ActiveLightIndex);
		float ShadowMul165 = 1.0;
		if (_LightShadowOn)
		{
			ShadowMapOutput ShadowMap178;

			mat4 _LightViewPrj = GetLightViewPrj(ActiveLightIndex);
			ShadowMap178 = ShadowMapFunction(ActiveLightIndex, _LightType, _LightViewPrj, 0.01, VertexWorldPosition);			
			
			vec3 _LightShadowColor = GetLightShadowColor(ActiveLightIndex);
			float ShadowColorMix = ShadowMap178.LightGain;
			ShadowMul165 = ShadowColorMix;
		}
		float DecayShadowConeMul = ((ShadowMul165 * ConeMul164) * DecayMul162);
		vec3 _LightColor = GetLightColor(ActiveLightIndex);
		vec3 MulItensity = ((_LightColor * DecayShadowConeMul) * _LightIntensity);
		OUT.Light = MulItensity;

		return OUT;
	}

	// -------------------------------------- BlinnSpecularFunction --------------------------------------
	struct BlinnSpecularOutput
	{
		vec3 SpecularColor;
	};

	BlinnSpecularOutput BlinnSpecularFunction(int ActiveLightIndex, vec3 LightVector, vec3 Normal, vec3 CameraVector, float SpecularPower, vec3 SpecularColor)
	{
		BlinnSpecularOutput OUT;

		vec3 NormOp = normalize((LightVector + CameraVector));
		float SatOp = clamp(dot(Normal, NormOp), 0.0, 1.0);
		vec3 BlinnSpec = (SpecularColor * pow(SatOp, SpecularPower));
		float SatOp626 = clamp(dot(Normal, LightVector), 0.0, 1.0);
		vec3 MulOp = (SatOp626 * BlinnSpec);
		OUT.SpecularColor = MulOp;

		return OUT;
	}

	// -------------------------------------- RotateVectorFunction --------------------------------------
	struct RotateVectorOutput
	{
		float FirstAxis;
		float SecondAxis;
	};

	RotateVectorOutput RotateVectorFunction(float FirstAxis, float SecondAxis, float DegreesOrRotation)
	{
		RotateVectorOutput OUT;

		float Angle = radians(DegreesOrRotation);
		float CosOp = cos(Angle);
		float SinOp = sin(Angle);
		float axisOne = ((CosOp * FirstAxis) - (SinOp * SecondAxis));
		float axisTwo = ((FirstAxis * SinOp) + (SecondAxis * CosOp));
		OUT.FirstAxis = axisOne;
		OUT.SecondAxis = axisTwo;

		return OUT;
	}

	// -------------------------------------- GetShadowPassPixelDepthGLFunction --------------------------------------
	struct GetShadowPassPixelDepthGLOutput
	{
		float Depth;
	};

	GetShadowPassPixelDepthGLOutput GetShadowPassPixelDepthGLFunction(vec4 VertexWorldPosition, mat4 ShadowPrjMatrix)
	{
		GetShadowPassPixelDepthGLOutput OUT;

		vec4 MulOp = (ShadowPrjMatrix * VertexWorldPosition);
		float DepthPerPixel = (MulOp.z / MulOp.w);
		float AddOp = (DepthPerPixel + fwidth(DepthPerPixel));
		float NormalMap = (0.5 * AddOp);
		float AddOp993 = (NormalMap + 0.5);
		OUT.Depth = AddOp993;

		return OUT;
	}

	// -------------------------------------- PixelToLightDistanceGLFunction --------------------------------------
	struct PixelToLightDistanceGLOutput
	{
		float Distance;
	};

	PixelToLightDistanceGLOutput PixelToLightDistanceGLFunction(vec4 VertexWorldPosition)
	{
		PixelToLightDistanceGLOutput OUT;

		vec3 LightToVertex = vec3(0.0, 0.0, 0.0);

		LightToVertex = VertexWorldPosition.xyz - viewI[3].xyz;
		OUT.Distance = length(LightToVertex)/DepthRange;

		return OUT;
	}
}

// -------------------------------------- ShaderPixelP1 --------------------------------------
attribute PIXELDATAP1
{
	vec4 outColor : COLOR0;
};

GLSLShader ShaderPixelP1
{
	void main(void)
	{
		GetShadowPassPixelDepthGLOutput GetShadowPassPixelDepthGL983 = GetShadowPassPixelDepthGLFunction(PS_IN.WorldPosition, shadowViewPrj);
		vec4 VectorConstruct = vec4(GetShadowPassPixelDepthGL983.Depth, GetShadowPassPixelDepthGL983.Depth, GetShadowPassPixelDepthGL983.Depth, GetShadowPassPixelDepthGL983.Depth);
		outColor = VectorConstruct;
	}
}

technique Main
{
	pass P0
	<
		string drawContext = "colorPass";
	>
	{
        VertexShader (in appdata, out cellVertexOutput) = VS;
        PixelShader (in cellVertexOutput, out pixelOut) = FS;
	}

	pass P1
	<
		string drawContext = "shadowPass";
	>
	{
		VertexShader (in appdata, out cellVertexOutput) = VS;
		PixelShader (in cellVertexOutput PS_IN, out PIXELDATAP1) = { PixelShader_Funcs, ShaderPixelP1};
	}
}
