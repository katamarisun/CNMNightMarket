#version 410
// ----------------------------------------- Header ------------------------------------------
#ifndef SFX_OGSFX
	#define SFX_OGSFX
#endif 
#ifndef _MAYA_
	#define _MAYA_
#endif 



#define float2 vec2
#define float3 vec3
#define float4 vec4
#define float3x3 mat3
#define float4x4 mat4
#ifdef COMPILING_VS
	#define OUTIN out 
#else 
	#define OUTIN in 
#endif 
#ifndef half 
	#define half float 
	#define half2 float2 
	#define half3 float3 
	#define half4 float4 
#endif 


uniform float2 ShadowFilterTaps[10] = {{-0.840520, -0.073954}, {-0.326235, -0.405830}, {-0.698464, 0.457259}, {-0.203356, 0.620585}, {0.963450, -0.194353}, {0.473434, -0.480026}, {0.519454, 0.767034}, {0.185461, -0.894523}, {0.507351, 0.064963}, {-0.321932, 0.595435}};



// ----------------------------------- Per Frame --------------------------------------
uniform float4x4 viewI : ViewInverse < string UIWidget = "None"; >;

uniform 	bool MayaHwFogEnabled : HardwareFogEnabled < string UIWidget = "None"; > = false; 
uniform 	int MayaHwFogMode : HardwareFogMode < string UIWidget = "None"; > = 0; 
uniform 	float MayaHwFogStart : HardwareFogStart < string UIWidget = "None"; > = 0.0; 
uniform 	float MayaHwFogEnd : HardwareFogEnd < string UIWidget = "None"; > = 100.0; 
uniform 	float MayaHwFogDensity : HardwareFogDensity < string UIWidget = "None"; > = 0.1; 
uniform 	float4 MayaHwFogColor : HardwareFogColor < string UIWidget = "None"; > = { 0.5, 0.5, 0.5, 1.0 }; 


uniform float4x4 viewPrj : ViewProjection < string UIWidget = "None"; >;

uniform float4x4 view : View < string UIWidget = "None"; >;


// --------------------------------------- Per Object -----------------------------------------
uniform float4x4 world : World < string UIWidget = "None"; >;

uniform int ClampDynamicLights
<
	float UIMin = 0;
	float UISoftMin = 0;
	float UIMax = 99;
	float UISoftMax = 99;
	float UIStep = 1;
	string UIName = "ClampDynamicLights";
	string UIWidget = "Slider";
> = 99;

uniform float4x4 wvp : WorldViewProjection < string UIWidget = "None"; >;


// ----------------------------------- Lights --------------------------------------
uniform int Light0Type : LIGHTTYPE
<
	string UIName =  "Light 0 Type";
	float UIMin = 0;
	float UIMax = 5;
	float UIStep = 1;
	string UIWidget = "None";
	string Object =  "Light 0";
> = 3;

uniform int Light1Type : LIGHTTYPE
<
	string UIName =  "Light 1 Type";
	float UIMin = 0;
	float UIMax = 5;
	float UIStep = 1;
	string UIWidget = "None";
	string Object =  "Light 1";
> = 3;

uniform int Light2Type : LIGHTTYPE
<
	string UIName =  "Light 2 Type";
	float UIMin = 0;
	float UIMax = 5;
	float UIStep = 1;
	string UIWidget = "None";
	string Object =  "Light 2";
> = 3;

uniform float3 Light0Color : LIGHTCOLOR
<
	string UIName =  "Light 0 Color";
	string UIWidget = "ColorPicker";
	string Object =  "Light 0";
> = {1.0, 1.0, 1.0};

uniform float3 Light1Color : LIGHTCOLOR
<
	string UIName =  "Light 1 Color";
	string UIWidget = "ColorPicker";
	string Object =  "Light 1";
> = {1.0, 1.0, 1.0};

uniform float3 Light2Color : LIGHTCOLOR
<
	string UIName =  "Light 2 Color";
	string UIWidget = "ColorPicker";
	string Object =  "Light 2";
> = {1.0, 1.0, 1.0};

uniform float Light0Intensity : LIGHTINTENSITY
<
	string UIName =  "Light 0 Intensity";
	float UIMin = 0;
	float UIStep = 0.1;
	string Object =  "Light 0";
> = 1.0;

uniform float Light1Intensity : LIGHTINTENSITY
<
	string UIName =  "Light 1 Intensity";
	float UIMin = 0;
	float UIStep = 0.1;
	string Object =  "Light 1";
> = 1.0;

uniform float Light2Intensity : LIGHTINTENSITY
<
	string UIName =  "Light 2 Intensity";
	float UIMin = 0;
	float UIStep = 0.1;
	string Object =  "Light 2";
> = 1.0;

uniform float3 Light0Pos : POSITION
<
	string UIName =  "Light 0 Position";
	string Space = "World";
	string Object =  "Light 0";
> = {1.0, 1.0, 1.0};

uniform float3 Light1Pos : POSITION
<
	string UIName =  "Light 1 Position";
	string Space = "World";
	string Object =  "Light 1";
> = {1.0, 1.0, 1.0};

uniform float3 Light2Pos : POSITION
<
	string UIName =  "Light 2 Position";
	string Space = "World";
	string Object =  "Light 2";
> = {1.0, 1.0, 1.0};

uniform float3 Light0Dir : DIRECTION
<
	string UIName =  "Light 0 Direction";
	string Space = "World";
	string Object =  "Light 0";
> = {0.0, -1.0, 0.0};

uniform float3 Light1Dir : DIRECTION
<
	string UIName =  "Light 1 Direction";
	string Space = "World";
	string Object =  "Light 1";
> = {0.0, -1.0, 0.0};

uniform float3 Light2Dir : DIRECTION
<
	string UIName =  "Light 2 Direction";
	string Space = "World";
	string Object =  "Light 2";
> = {0.0, -1.0, 0.0};

uniform float Light0Attenuation : DECAYRATE
<
	string UIName =  "Light 0 Decay";
	float UIMin = 0;
	float UIStep = 1;
	string Object =  "Light 0";
> = 0.000000;

uniform float Light1Attenuation : DECAYRATE
<
	string UIName =  "Light 1 Decay";
	float UIMin = 0;
	float UIStep = 1;
	string Object =  "Light 1";
> = 0.000000;

uniform float Light2Attenuation : DECAYRATE
<
	string UIName =  "Light 2 Decay";
	float UIMin = 0;
	float UIStep = 1;
	string Object =  "Light 2";
> = 0.000000;

uniform float Light0ConeAngle : HOTSPOT
<
	string UIName =  "Light 0 ConeAngle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Space = "World";
	string Object =  "Light 0";
> = 0.46;

uniform float Light1ConeAngle : HOTSPOT
<
	string UIName =  "Light 1 ConeAngle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Space = "World";
	string Object =  "Light 1";
> = 0.46;

uniform float Light2ConeAngle : HOTSPOT
<
	string UIName =  "Light 2 ConeAngle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Space = "World";
	string Object =  "Light 2";
> = 0.46;

uniform float Light0Falloff : FALLOFF
<
	string UIName =  "Light 0 Penumbra Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Object =  "Light 0";
> = 0.7;

uniform float Light1Falloff : FALLOFF
<
	string UIName =  "Light 1 Penumbra Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Object =  "Light 1";
> = 0.7;

uniform float Light2Falloff : FALLOFF
<
	string UIName =  "Light 2 Penumbra Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Object =  "Light 2";
> = 0.7;

uniform bool Light0ShadowOn : SHADOWFLAG
<
	string UIName =  "Light 0 Shadow";
	string Object =  "Light 0";
> = true;

uniform bool Light1ShadowOn : SHADOWFLAG
<
	string UIName =  "Light 1 Shadow";
	string Object =  "Light 1";
> = true;

uniform bool Light2ShadowOn : SHADOWFLAG
<
	string UIName =  "Light 2 Shadow";
	string Object =  "Light 2";
> = true;

uniform float4x4 Light0ViewPrj : SHADOWMAPMATRIX
<
	string Object =  "Light 0";
	string UIName =  "Light 0 Matrix";
	string UIWidget = "None";
	int LightRef = 1;
>;

uniform float4x4 Light1ViewPrj : SHADOWMAPMATRIX
<
	string Object =  "Light 1";
	string UIName =  "Light 1 Matrix";
	string UIWidget = "None";
	int LightRef = 2;
>;

uniform float4x4 Light2ViewPrj : SHADOWMAPMATRIX
<
	string Object =  "Light 2";
	string UIName =  "Light 2 Matrix";
	string UIWidget = "None";
	int LightRef = 3;
>;

uniform float Light0ShadowBias : SHADOWBIAS
<
	string UIName =  "Light 0 Shadow Bias";
	string Object =  "Light 0";
> = 0.01;

uniform float Light1ShadowBias : SHADOWBIAS
<
	string UIName =  "Light 1 Shadow Bias";
	string Object =  "Light 1";
> = 0.01;

uniform float Light2ShadowBias : SHADOWBIAS
<
	string UIName =  "Light 2 Shadow Bias";
	string Object =  "Light 2";
> = 0.01;

uniform float3 Light0ShadowColor : SHADOWCOLOR
<
	string UIName =  "Light 0 Shadow Color";
	string Object =  "Light 0";
> = {0, 0, 0};

uniform float3 Light1ShadowColor : SHADOWCOLOR
<
	string UIName =  "Light 1 Shadow Color";
	string Object =  "Light 1";
> = {0, 0, 0};

uniform float3 Light2ShadowColor : SHADOWCOLOR
<
	string UIName =  "Light 2 Shadow Color";
	string Object =  "Light 2";
> = {0, 0, 0};


// ---------------------------------------- Textures -----------------------------------------
uniform texture2D Light0ShadowMap : SHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "2D";
	string UIWidget = "None";
	string Object =  "Light 0";
>;

uniform texture2D Light1ShadowMap : SHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "2D";
	string UIWidget = "None";
	string Object =  "Light 1";
>;

uniform texture2D Light2ShadowMap : SHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "2D";
	string UIWidget = "None";
	string Object =  "Light 2";
>;

uniform sampler2D Light0ShadowMapSampler = sampler_state 
{
	Texture = <Light0ShadowMap>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};

uniform sampler2D Light1ShadowMapSampler = sampler_state 
{
	Texture = <Light1ShadowMap>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};

uniform sampler2D Light2ShadowMapSampler = sampler_state 
{
	Texture = <Light2ShadowMap>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};

uniform texture2D TransDepthTexture : transpdepthtexture
<
	string ResourceName = "";
	string UIName = "TransDepthTexture";
	string ResourceType = "2D";
	string UIWidget = "None";
>;

uniform texture2D OpaqueDepthTexture : opaquedepthtexture
<
	string ResourceName = "";
	string UIName = "OpaqueDepthTexture";
	string ResourceType = "2D";
	string UIWidget = "None";
>;

uniform sampler2D TransDepthTextureSampler = sampler_state 
{
	Texture = <TransDepthTexture>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};

uniform sampler2D OpaqueDepthTextureSampler = sampler_state 
{
	Texture = <OpaqueDepthTexture>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};


GLSLShader Common_Funcs
{
}

GLSLShader VertexShader_Funcs
{
}

GLSLShader TessControlShader_Funcs
{
}

GLSLShader TessEvaluationShader_Funcs
{
}

GLSLShader GeometryShader_Funcs
{
}

GLSLShader PixelShader_Funcs
{
int GetLightType(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0Type; 
	else if (ActiveLightIndex == 1) 
		return Light1Type; 
	else 
		return Light2Type; 
}

float3 GetLightColor(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0Color; 
	else if (ActiveLightIndex == 1) 
		return Light1Color; 
	else 
		return Light2Color; 
}

float GetLightIntensity(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0Intensity; 
	else if (ActiveLightIndex == 1) 
		return Light1Intensity; 
	else 
		return Light2Intensity; 
}

float3 GetLightPos(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0Pos; 
	else if (ActiveLightIndex == 1) 
		return Light1Pos; 
	else 
		return Light2Pos; 
}

float3 GetLightDir(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0Dir; 
	else if (ActiveLightIndex == 1) 
		return Light1Dir; 
	else 
		return Light2Dir; 
}

float GetLightAttenuation(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0Attenuation; 
	else if (ActiveLightIndex == 1) 
		return Light1Attenuation; 
	else 
		return Light2Attenuation; 
}

float GetLightConeAngle(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0ConeAngle; 
	else if (ActiveLightIndex == 1) 
		return Light1ConeAngle; 
	else 
		return Light2ConeAngle; 
}

float GetLightFalloff(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0Falloff; 
	else if (ActiveLightIndex == 1) 
		return Light1Falloff; 
	else 
		return Light2Falloff; 
}

bool GetLightShadowOn(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0ShadowOn; 
	else if (ActiveLightIndex == 1) 
		return Light1ShadowOn; 
	else 
		return Light2ShadowOn; 
}

float4x4 GetLightViewPrj(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0ViewPrj; 
	else if (ActiveLightIndex == 1) 
		return Light1ViewPrj; 
	else 
		return Light2ViewPrj; 
}

float GetLightShadowBias(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0ShadowBias; 
	else if (ActiveLightIndex == 1) 
		return Light1ShadowBias; 
	else 
		return Light2ShadowBias; 
}

float4 SampleFromShadowMap( int ActiveLightIndex, float2 UVs) 
{ 
	if (ActiveLightIndex == 0) 
		return textureLod(Light0ShadowMapSampler, UVs, 0); 
	else if (ActiveLightIndex == 1) 
		return textureLod(Light1ShadowMapSampler, UVs, 0); 
	else 
		return textureLod(Light2ShadowMapSampler, UVs, 0); 
}

float3 GetLightShadowColor(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return Light0ShadowColor; 
	else if (ActiveLightIndex == 1) 
		return Light1ShadowColor; 
	else 
		return Light2ShadowColor; 
}

float4 sampleTransDepthTex(float2 UV)
{
	float4 col = float4(0,0,0,0);

	#if defined(SFX_CGFX_3) || defined(SFX_HLSL_3)
		col = tex2D( TransDepthTextureSampler, UV );
	#endif
	#ifdef SFX_HLSL_5
		#if defined(SFX_SWATCH) || defined(_3DSMAX_)
			col = TransDepthTexture.Sample( TransDepthTextureSampler, UV );
		#else
			col = TransDepthTexture.Sample( TransDepthTextureSampler, UV );
		#endif
	#endif
	#ifdef SFX_GLSL_4
		col = texture( TransDepthTexture, UV );
	#endif
	#ifdef SFX_OGSFX
		col = texture( TransDepthTextureSampler, UV );
	#endif
	#ifdef SFX_GLSL_1_2
		col = texture2D( TransDepthTexture, UV );
	#endif

	return col;
}

float4 sampleOpaqueDepthTex(float2 UV)
{
	float4 col = float4(0,0,0,0);

	#if defined(SFX_CGFX_3) || defined(SFX_HLSL_3)
		col = tex2D( OpaqueDepthTextureSampler, UV );
	#endif
	#ifdef SFX_HLSL_5
		#if defined(SFX_SWATCH) || defined(_3DSMAX_)
			col = OpaqueDepthTexture.Sample( OpaqueDepthTextureSampler, UV );
		#else
			col = OpaqueDepthTexture.Sample( OpaqueDepthTextureSampler, UV );
		#endif
	#endif
	#ifdef SFX_GLSL_4
		col = texture( OpaqueDepthTexture, UV );
	#endif
	#ifdef SFX_OGSFX
		col = texture( OpaqueDepthTextureSampler, UV );
	#endif
	#ifdef SFX_GLSL_1_2
		col = texture2D( OpaqueDepthTexture, UV );
	#endif

	return col;
}

struct DepthPeelOutput 
{ 
	float4 LinearDepth; 
	float Peel;
}; 

DepthPeelOutput DepthPeelFunc( float3 worldPos, float4x4 view, float4x4 viewPrj ) 
{ 
	DepthPeelOutput OUT; 

	#ifdef SFX_CGFX_3
		float currZ = abs( mul( view, float4(worldPos, 1.0f) ).z );
		float4 Pndc  = mul( viewPrj, float4(worldPos, 1.0f) );
		float2 UV = Pndc.xy / Pndc.w * float2(0.5f, 0.5f) + 0.5f;

		float prevZ = sampleTransDepthTex(UV).r;
		float opaqZ = sampleOpaqueDepthTex(UV).r;
		float bias = 0.00002f;
		if (currZ < prevZ * (1.0f + bias) || currZ > opaqZ * (1.0f - bias))
		{
			discard;
		}

		float ld = abs( mul( view, float4(worldPos, 1.0f) ).z );
		OUT.LinearDepth = float4(ld, ld, ld, ld);
	#else
	#if defined(SFX_GLSL_1_2) || defined(SFX_GLSL_4) || defined(SFX_OGSFX)
		float currZ = abs( ( view * float4(worldPos, 1.0f) ).z );
		float4 Pndc  = viewPrj * float4(worldPos, 1.0f);
		float2 UV = Pndc.xy / Pndc.w * float2(0.5f, 0.5f) + 0.5f;

		float prevZ = sampleTransDepthTex(UV).r;
		float opaqZ = sampleOpaqueDepthTex(UV).r;
		float bias = 0.00002f;
		if (currZ < prevZ * (1.0f + bias) || currZ > opaqZ * (1.0f - bias))
		{
			discard;
		}

		float ld = abs( ( view * float4(worldPos, 1.0f) ).z );
		OUT.LinearDepth = float4(ld, ld, ld, ld);
	#else
		float currZ = abs( mul( float4(worldPos, 1.0f), view ).z );
		float4 Pndc  = mul( float4(worldPos, 1.0f), viewPrj );
		float2 UV = Pndc.xy / Pndc.w * float2(0.5f, -0.5f) + 0.5f;

		float prevZ = sampleTransDepthTex(UV).r;
		float opaqZ = sampleOpaqueDepthTex(UV).r;
		float bias = 0.00002f;
		if (currZ < prevZ * (1.0f + bias) || currZ > opaqZ * (1.0f - bias))
		{
			discard;
		}

		float ld = abs( mul( float4(worldPos, 1.0f), view ).z );
		OUT.LinearDepth = float4(ld, ld, ld, ld);
#endif
	#endif

	OUT.Peel = 1.0f;

	return OUT; 
} 


// -------------------------------------- AmbientLightFunction --------------------------------------
struct AmbientLightOutput
{
	float3 LightColor;
};

AmbientLightOutput AmbientLightFunction(int ActiveLightIndex, float3 AlbedoColor, float3 LightColor, float LightIntensity)
{
	AmbientLightOutput OUT;

	float3 MulOp = ((LightColor * AlbedoColor) * LightIntensity);
	OUT.LightColor = MulOp;

	return OUT;
}

// -------------------------------------- GetLightVectorFunction --------------------------------------
struct GetLightVectorOutput
{
	float3 Result;
};

GetLightVectorOutput GetLightVectorFunction(int ActiveLightIndex, float3 LightPosition, float3 VertexWorldPosition, int LightType, float3 LightDirection)
{
	GetLightVectorOutput OUT;

	bool IsDirectionalLight = (LightType == 4);
	float3 LerpOp = mix((LightPosition - VertexWorldPosition), -(LightDirection), float(IsDirectionalLight));
	OUT.Result = LerpOp;

	return OUT;
}

// -------------------------------------- LambertDiffuseFunction --------------------------------------
struct LambertDiffuseOutput
{
	float3 Color;
};

LambertDiffuseOutput LambertDiffuseFunction(int ActiveLightIndex, float3 AlbedoColor, float3 Normal, float3 LightVector)
{
	LambertDiffuseOutput OUT;

	float SatOp = clamp(dot(Normal, LightVector), 0.0, 1.0);
	float3 Diffuse = (SatOp * AlbedoColor);
	OUT.Color = Diffuse;

	return OUT;
}

// -------------------------------------- LightDecayFunction --------------------------------------
struct LightDecayOutput
{
	float Attenuation;
};

LightDecayOutput LightDecayFunction(int ActiveLightIndex, float3 LightVectorUN, float Attenuation)
{
	LightDecayOutput OUT;

	bool IsAttenuationUsed = (Attenuation > 0.001000);
	float DecayContribution463 = 0.0;
	if (IsAttenuationUsed)
	{
		float PowOp = pow(length(LightVectorUN), Attenuation);
		float DivOp = (1.000000 / PowOp);
		DecayContribution463 = DivOp;
	}
	else
	{
		DecayContribution463 = 1.000000;
	}
	OUT.Attenuation = DecayContribution463;

	return OUT;
}

// -------------------------------------- LightConeAngleFunction --------------------------------------
struct LightConeAngleOutput
{
	float ConeAngle;
};

LightConeAngleOutput LightConeAngleFunction(int ActiveLightIndex, float3 LightVector, float3 LightDirection, float ConeAngle, float ConeFalloff)
{
	LightConeAngleOutput OUT;

	float CosOp = cos(max(ConeFalloff, ConeAngle));
	float DotOp = dot(LightVector, -(LightDirection));
	float SmoothStepOp = smoothstep(CosOp, cos(ConeAngle), DotOp);
	OUT.ConeAngle = SmoothStepOp;

	return OUT;
}

// -------------------------------------- ShadowMapFunction --------------------------------------
struct ShadowMapOutput
{
	float LightGain;
};

ShadowMapOutput ShadowMapFunction(int ActiveLightIndex, float4x4 LightViewPrj, float ShadowMapBias, float3 VertexWorldPosition)
{
	ShadowMapOutput OUT;

	float IfElseOp546 = 0.0;
	float4 VectorConstruct = float4(VertexWorldPosition.x, VertexWorldPosition.y, VertexWorldPosition.z, 1.000000);
	float4 MulOp = (LightViewPrj * VectorConstruct);
	float3 DivOp = (MulOp.xyz / MulOp.w);
	if (DivOp.x > -1.000000 && DivOp.x < 1.000000 && DivOp.y > -1.000000 && DivOp.y < 1.000000 && DivOp.z > 0.000000 && DivOp.z < 1.000000)
	{
		float Val = 0.500000;
		float2 AddOp = ((Val * DivOp.xy) + Val);
		float SubOp = (DivOp.z - (ShadowMapBias / MulOp.w));
		float ShadowTotal = 0.000000;
		for(int i=0; i<10; i+=1)
		{
			float2 MulOp586 = (0.000900 * ShadowFilterTaps[i]);
			float2 AddOp587 = (AddOp + MulOp586);
			float4 Sampler = SampleFromShadowMap(ActiveLightIndex, AddOp587);
			float IfElseOp540 = ((SubOp - Sampler.x) >= 0.000000) ? (0.000000) : (0.100000);
			ShadowTotal += IfElseOp540;
		}
		IfElseOp546 = ShadowTotal;
	}
	else
	{
		IfElseOp546 = 1.000000;
	}
	OUT.LightGain = IfElseOp546;

	return OUT;
}

// -------------------------------------- LightContributionFunction --------------------------------------
struct LightContributionOutput
{
	float3 Light;
};

LightContributionOutput LightContributionFunction(int ActiveLightIndex, float3 VertexWorldPosition, float3 LightVectorUN)
{
	LightContributionOutput OUT;

	float _LightIntensity = GetLightIntensity(ActiveLightIndex);
	int _LightType = GetLightType(ActiveLightIndex);
	bool IsDirectionalLight = (_LightType == 4);
	float DecayMul509 = 0.0;
	if (IsDirectionalLight)
	{
		DecayMul509 = 1.000000;
	}
	else
	{
		float _LightAttenuation = GetLightAttenuation(ActiveLightIndex);
		LightDecayOutput LightDecay457 = LightDecayFunction(ActiveLightIndex, LightVectorUN, _LightAttenuation);
		DecayMul509 = LightDecay457.Attenuation;
	}
	bool IsSpotLight = (_LightType == 2);
	float ConeMul511 = 1.000000;
	if (IsSpotLight)
	{
		float3 NormOp = normalize(LightVectorUN);
		float3 _LightDir = GetLightDir(ActiveLightIndex);
		float _LightConeAngle = GetLightConeAngle(ActiveLightIndex);
		float _LightFalloff = GetLightFalloff(ActiveLightIndex);
		LightConeAngleOutput LightConeAngle399 = LightConeAngleFunction(ActiveLightIndex, NormOp, _LightDir, _LightConeAngle, _LightFalloff);
		ConeMul511 = LightConeAngle399.ConeAngle;
	}
	bool _LightShadowOn = GetLightShadowOn(ActiveLightIndex);
	float ShadowMul512 = 1.000000;
	if (_LightShadowOn)
	{
		float4x4 _LightViewPrj = GetLightViewPrj(ActiveLightIndex);
		float _LightShadowBias = GetLightShadowBias(ActiveLightIndex);
		ShadowMapOutput ShadowMap525 = ShadowMapFunction(ActiveLightIndex, _LightViewPrj, _LightShadowBias, VertexWorldPosition);
		float3 _LightShadowColor = GetLightShadowColor(ActiveLightIndex);
		float ShadowColorMix = mix(ShadowMap525.LightGain, 1.000000, float(_LightShadowColor.x));
		ShadowMul512 = ShadowColorMix;
	}
	float DecayShadowConeMul = ((ShadowMul512 * ConeMul511) * DecayMul509);
	float3 _LightColor = GetLightColor(ActiveLightIndex);
	float3 MulItensity = ((_LightColor * DecayShadowConeMul) * _LightIntensity);
	OUT.Light = MulItensity;

	return OUT;
}

// -------------------------------------- WardAnisotropicFunction --------------------------------------
struct WardAnisotropicOutput
{
	float3 SpecularColor;
};

WardAnisotropicOutput WardAnisotropicFunction(int ActiveLightIndex, float3 Normal, float3 CameraVector, float3 LightVector, float3 AnisotropicDirection, float2 AnisotropicRoughness, float3 AnisotropicColor)
{
	WardAnisotropicOutput OUT;

	float3 H = normalize((CameraVector + LightVector));
	float dotHDirRough1 = (dot(H, AnisotropicDirection) / AnisotropicRoughness.x);
	float DotOp = dot(H, cross(Normal, AnisotropicDirection));
	float dotHBRough2 = (DotOp / AnisotropicRoughness.y);
	float AddOp = ((dotHDirRough1 * dotHDirRough1) + (dotHBRough2 * dotHBRough2));
	float MulOp = (AddOp * -2.000000);
	float AddOp1080 = (1.000000 + dot(H, Normal));
	float ExpOp = exp((MulOp / AddOp1080));
	float NdotL = clamp(dot(Normal, LightVector), 0.0, 1.0);
	float DivOp = (NdotL / dot(Normal, CameraVector));
	float MaxOp = max(0.000000, DivOp);
	float3 MulOp1067 = (AnisotropicColor * 1.000000);
	float3 MulOp1072 = (MulOp1067 * sqrt(MaxOp));
	float3 SpecularColor = (MulOp1072 * ExpOp);
	OUT.SpecularColor = SpecularColor;

	return OUT;
}

// -------------------------------------- DesaturateColorFunction --------------------------------------
struct DesaturateColorOutput
{
	float DesaturateColor;
};

DesaturateColorOutput DesaturateColorFunction(int ActiveLightIndex, float3 Color)
{
	DesaturateColorOutput OUT;

	float3 Col = float3(0.300008,0.600000,0.100008);
	float DotOp = dot(clamp(Color, 0.0, 1.0), Col.xyz);
	OUT.DesaturateColor = DotOp;

	return OUT;
}

// -------------------------------------- DesaturateColorFunction --------------------------------------
DesaturateColorOutput DesaturateColorFunction(float3 Color)
{
	DesaturateColorOutput OUT;

	float3 Col = float3(0.300008,0.600000,0.100008);
	float DotOp = dot(clamp(Color, 0.0, 1.0), Col.xyz);
	OUT.DesaturateColor = DotOp;

	return OUT;
}

}

// -------------------------------------- ShaderVertex --------------------------------------
attribute APPDATA
{
	float3 inPosition : POSITION;
	float3 inNormal : NORMAL;
	float3 inTangent : TANGENT;
};

attribute SHADERDATA
{
	float4 Normal : NORMAL;
	float4 WorldPosition : TEXCOORD0;
	float4 Tangent : TANGENT;
	half3 FogFactor : TEXCOORD1;
};

GLSLShader ShaderVertex
{
void main(void)
{
	gl_Position = float4(inPosition, 1);
	float3 MulOp = ((float3x3(world)) * inNormal);
	float3 NormalN = normalize(MulOp);
	float4 WorldNormal = float4(NormalN.x, NormalN.y, NormalN.z, 1.000000);
	VS_OUT.Normal = WorldNormal;
	float4 WorldPos = (world * gl_Position);
	VS_OUT.WorldPosition = WorldPos;
	float3 MulOp1150 = ((float3x3(world)) * inTangent);
	float3 TangentNorm = normalize(MulOp1150);
	float4 WorldTangent = float4(TangentNorm.x, TangentNorm.y, TangentNorm.z, 1.000000);
	VS_OUT.Tangent = WorldTangent;
	VS_OUT.WorldPosition = (world * float4(inPosition, 1));
	float4 _HPosition = mul( viewPrj, float4(VS_OUT.WorldPosition.xyz, 1) ); 
	float fogFactor = 0.0; 
	if (MayaHwFogMode == 0) { 
				fogFactor = saturate((MayaHwFogEnd - _HPosition.z) / (MayaHwFogEnd - MayaHwFogStart)); 
	} 
	else if (MayaHwFogMode == 1) { 
				fogFactor = 1.0 / (exp(_HPosition.z * MayaHwFogDensity)); 
	} 
	else if (MayaHwFogMode == 2) { 
				fogFactor = 1.0 / (exp(pow(_HPosition.z * MayaHwFogDensity, 2))); 
	} 
	VS_OUT.FogFactor = float3(fogFactor, fogFactor, fogFactor); 

	float4 WVSpace = (wvp * gl_Position);
	gl_Position = WVSpace;
}

}

// -------------------------------------- ShaderPixel --------------------------------------
attribute PIXELDATA
{
	float4 outColor : COLOR0;
};

GLSLShader ShaderPixel
{
void main(void)
{
	float InvertSatMask = (1.000000 - clamp(0.000000, 0.0, 1.0));
	float3 Color = float3(0.500000,0.500000,0.500000);
	float3 ReplaceDiffuseWithReflection = (Color.xyz * InvertSatMask);
	float3 NormOp = normalize(PS_IN.Normal.xyz);
	float3 FlippedNormals = mix(-(NormOp), NormOp, float(gl_FrontFacing));
	float ClampOpacity = clamp(1.000000, 0.0, 1.0);
	float3 CameraPosition = viewI[3].xyz;
	float3 CamVec = (CameraPosition - PS_IN.WorldPosition.xyz);
	float3 CamVecNorm = normalize(CamVec);
	float4 LightLoopTotal11 = float4(0,0,0,0);
	for (int ActiveLightIndex = 0; ActiveLightIndex < 3; ++ActiveLightIndex)
	{
		if (ActiveLightIndex >= ClampDynamicLights) {continue;}
		int _LightType = GetLightType(ActiveLightIndex);
		bool IsAmbientLight = (_LightType == 5);
		float4 IfAmbientLight384 = float4(0, 0, 0, 0);
		if (IsAmbientLight)
		{
			float3 _LightColor = GetLightColor(ActiveLightIndex);
			float _LightIntensity = GetLightIntensity(ActiveLightIndex);
			AmbientLightOutput AmbientLight389 = AmbientLightFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, _LightColor, _LightIntensity);
			float3 PreMulAlphaAmbient = (ClampOpacity * (AmbientLight389.LightColor * 1.000000));
			float4 VectorConstruct = float4(PreMulAlphaAmbient.x, PreMulAlphaAmbient.y, PreMulAlphaAmbient.z, 0.000000);
			IfAmbientLight384 = VectorConstruct;
		}
		else
		{
			float3 NoTranslucency = float3(0.000000,0.000000,0.000000);
			float3 _LightPos = GetLightPos(ActiveLightIndex);
			float3 _LightDir = GetLightDir(ActiveLightIndex);
			GetLightVectorOutput GetLightVector848 = GetLightVectorFunction(ActiveLightIndex, _LightPos, PS_IN.WorldPosition.xyz, _LightType, _LightDir);
			float3 LightVecNorm = normalize(GetLightVector848.Result);
			LambertDiffuseOutput LambertDiffuse823 = LambertDiffuseFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, FlippedNormals, LightVecNorm);
			LightContributionOutput LightContribution397 = LightContributionFunction(ActiveLightIndex, PS_IN.WorldPosition.xyz, GetLightVector848.Result);
			float3 AddTranslucency = (NoTranslucency.xyz + (LightContribution397.Light * LambertDiffuse823.Color));
			float3 NormOp1158 = normalize(PS_IN.Tangent.xyz);
			float2 AnisotropicRougness = float2(0.200000, 0.400000);
			float3 AnisotropicColor = float3(1.000000,1.000000,1.000000);
			WardAnisotropicOutput WardAnisotropic1051 = WardAnisotropicFunction(ActiveLightIndex, FlippedNormals, CamVecNorm, LightVecNorm, NormOp1158, AnisotropicRougness, AnisotropicColor.xyz);
			float3 SpecLightIntensity = (WardAnisotropic1051.SpecularColor * LightContribution397.Light);
			float3 Diffuse_Spec = ((ClampOpacity * AddTranslucency) + SpecLightIntensity);
			DesaturateColorOutput DesaturateColor664 = DesaturateColorFunction(ActiveLightIndex, SpecLightIntensity);
			float4 Color_Alpha = float4(Diffuse_Spec.x, Diffuse_Spec.y, Diffuse_Spec.z, DesaturateColor664.DesaturateColor);
			IfAmbientLight384 = Color_Alpha;
		}
		float4 ApplyWeight395 = IfAmbientLight384;
		LightLoopTotal11 += ApplyWeight395;
	}
	float3 NoReflection = float3(0.000000,0.000000,0.000000);
	float3 ReflectXmask = (NoReflection.xyz * 0.000000);
	float3 DefaultEmissiveColor = float3(0.000000,0.000000,0.000000);
	float3 DefaultIBLColor = float3(0.000000,0.000000,0.000000);
	float3 PreMultipliedAlpha = (ClampOpacity * (DefaultEmissiveColor.xyz + DefaultIBLColor.xyz));
	float3 AddReflection = (ReflectXmask + PreMultipliedAlpha);
	DesaturateColorOutput DesaturateColor363 = DesaturateColorFunction(ReflectXmask);
	float OpacityAndReflection = (ClampOpacity + DesaturateColor363.DesaturateColor);
	float4 TotalAmbientAndOpacity = float4(AddReflection.x, AddReflection.y, AddReflection.z, OpacityAndReflection);
	float4 LightLoopAndAfterLoop = (LightLoopTotal11 + TotalAmbientAndOpacity);
	float SatOp = clamp(LightLoopAndAfterLoop.w, 0.0, 1.0);
	float4 VectorConstruct = float4(LightLoopAndAfterLoop.xyz.x, LightLoopAndAfterLoop.xyz.y, LightLoopAndAfterLoop.xyz.z, SatOp);
	if (MayaHwFogEnabled) { 
		float fogFactor = (1.0 - PS_IN.FogFactor.x) * MayaHwFogColor.a; 
		VectorConstruct.rgb	= lerp(VectorConstruct.rgb, MayaHwFogColor.rgb, fogFactor); 
	} 

	outColor = VectorConstruct;
}

}

// -------------------------------------- ShaderPixelP1 --------------------------------------
attribute PIXELDATAP1
{
	float4 outColor0 : COLOR0;
	float4 outColor1 : COLOR1;
};

GLSLShader ShaderPixelP1
{
void main(void)
{
	float4 outColor;
	float InvertSatMask = (1.000000 - clamp(0.000000, 0.0, 1.0));
	float3 Color = float3(0.500000,0.500000,0.500000);
	float3 ReplaceDiffuseWithReflection = (Color.xyz * InvertSatMask);
	float3 NormOp = normalize(PS_IN.Normal.xyz);
	float3 FlippedNormals = mix(-(NormOp), NormOp, float(gl_FrontFacing));
	float ClampOpacity = clamp(1.000000, 0.0, 1.0);
	float3 CameraPosition = viewI[3].xyz;
	float3 CamVec = (CameraPosition - PS_IN.WorldPosition.xyz);
	float3 CamVecNorm = normalize(CamVec);
	float4 LightLoopTotal11 = float4(0,0,0,0);
	for (int ActiveLightIndex = 0; ActiveLightIndex < 3; ++ActiveLightIndex)
	{
		if (ActiveLightIndex >= ClampDynamicLights) {continue;}
		int _LightType = GetLightType(ActiveLightIndex);
		bool IsAmbientLight = (_LightType == 5);
		float4 IfAmbientLight384 = float4(0, 0, 0, 0);
		if (IsAmbientLight)
		{
			float3 _LightColor = GetLightColor(ActiveLightIndex);
			float _LightIntensity = GetLightIntensity(ActiveLightIndex);
			AmbientLightOutput AmbientLight389 = AmbientLightFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, _LightColor, _LightIntensity);
			float3 PreMulAlphaAmbient = (ClampOpacity * (AmbientLight389.LightColor * 1.000000));
			float4 VectorConstruct = float4(PreMulAlphaAmbient.x, PreMulAlphaAmbient.y, PreMulAlphaAmbient.z, 0.000000);
			IfAmbientLight384 = VectorConstruct;
		}
		else
		{
			float3 NoTranslucency = float3(0.000000,0.000000,0.000000);
			float3 _LightPos = GetLightPos(ActiveLightIndex);
			float3 _LightDir = GetLightDir(ActiveLightIndex);
			GetLightVectorOutput GetLightVector848 = GetLightVectorFunction(ActiveLightIndex, _LightPos, PS_IN.WorldPosition.xyz, _LightType, _LightDir);
			float3 LightVecNorm = normalize(GetLightVector848.Result);
			LambertDiffuseOutput LambertDiffuse823 = LambertDiffuseFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, FlippedNormals, LightVecNorm);
			LightContributionOutput LightContribution397 = LightContributionFunction(ActiveLightIndex, PS_IN.WorldPosition.xyz, GetLightVector848.Result);
			float3 AddTranslucency = (NoTranslucency.xyz + (LightContribution397.Light * LambertDiffuse823.Color));
			float3 NormOp1158 = normalize(PS_IN.Tangent.xyz);
			float2 AnisotropicRougness = float2(0.200000, 0.400000);
			float3 AnisotropicColor = float3(1.000000,1.000000,1.000000);
			WardAnisotropicOutput WardAnisotropic1051 = WardAnisotropicFunction(ActiveLightIndex, FlippedNormals, CamVecNorm, LightVecNorm, NormOp1158, AnisotropicRougness, AnisotropicColor.xyz);
			float3 SpecLightIntensity = (WardAnisotropic1051.SpecularColor * LightContribution397.Light);
			float3 Diffuse_Spec = ((ClampOpacity * AddTranslucency) + SpecLightIntensity);
			DesaturateColorOutput DesaturateColor664 = DesaturateColorFunction(ActiveLightIndex, SpecLightIntensity);
			float4 Color_Alpha = float4(Diffuse_Spec.x, Diffuse_Spec.y, Diffuse_Spec.z, DesaturateColor664.DesaturateColor);
			IfAmbientLight384 = Color_Alpha;
		}
		float4 ApplyWeight395 = IfAmbientLight384;
		LightLoopTotal11 += ApplyWeight395;
	}
	float3 NoReflection = float3(0.000000,0.000000,0.000000);
	float3 ReflectXmask = (NoReflection.xyz * 0.000000);
	float3 DefaultEmissiveColor = float3(0.000000,0.000000,0.000000);
	float3 DefaultIBLColor = float3(0.000000,0.000000,0.000000);
	float3 PreMultipliedAlpha = (ClampOpacity * (DefaultEmissiveColor.xyz + DefaultIBLColor.xyz));
	float3 AddReflection = (ReflectXmask + PreMultipliedAlpha);
	DesaturateColorOutput DesaturateColor363 = DesaturateColorFunction(ReflectXmask);
	float OpacityAndReflection = (ClampOpacity + DesaturateColor363.DesaturateColor);
	float4 TotalAmbientAndOpacity = float4(AddReflection.x, AddReflection.y, AddReflection.z, OpacityAndReflection);
	float4 LightLoopAndAfterLoop = (LightLoopTotal11 + TotalAmbientAndOpacity);
	float SatOp = clamp(LightLoopAndAfterLoop.w, 0.0, 1.0);
	float4 VectorConstruct = float4(LightLoopAndAfterLoop.xyz.x, LightLoopAndAfterLoop.xyz.y, LightLoopAndAfterLoop.xyz.z, SatOp);
	outColor = VectorConstruct;
	DepthPeelOutput DepthPeel = DepthPeelFunc(PS_IN.WorldPosition.xyz, view, viewPrj);
	outColor0 = outColor;
	outColor1 = DepthPeel.LinearDepth;
}

}

// -------------------------------------- ShaderPixelP2 --------------------------------------
attribute PIXELDATAP2
{
	float4 outColor0 : COLOR0;
	float4 outColor1 : COLOR1;
};

GLSLShader ShaderPixelP2
{
void main(void)
{
	float4 outColor;
	float InvertSatMask = (1.000000 - clamp(0.000000, 0.0, 1.0));
	float3 Color = float3(0.500000,0.500000,0.500000);
	float3 ReplaceDiffuseWithReflection = (Color.xyz * InvertSatMask);
	float3 NormOp = normalize(PS_IN.Normal.xyz);
	float3 FlippedNormals = mix(-(NormOp), NormOp, float(gl_FrontFacing));
	float ClampOpacity = clamp(1.000000, 0.0, 1.0);
	float3 CameraPosition = viewI[3].xyz;
	float3 CamVec = (CameraPosition - PS_IN.WorldPosition.xyz);
	float3 CamVecNorm = normalize(CamVec);
	float4 LightLoopTotal11 = float4(0,0,0,0);
	for (int ActiveLightIndex = 0; ActiveLightIndex < 3; ++ActiveLightIndex)
	{
		if (ActiveLightIndex >= ClampDynamicLights) {continue;}
		int _LightType = GetLightType(ActiveLightIndex);
		bool IsAmbientLight = (_LightType == 5);
		float4 IfAmbientLight384 = float4(0, 0, 0, 0);
		if (IsAmbientLight)
		{
			float3 _LightColor = GetLightColor(ActiveLightIndex);
			float _LightIntensity = GetLightIntensity(ActiveLightIndex);
			AmbientLightOutput AmbientLight389 = AmbientLightFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, _LightColor, _LightIntensity);
			float3 PreMulAlphaAmbient = (ClampOpacity * (AmbientLight389.LightColor * 1.000000));
			float4 VectorConstruct = float4(PreMulAlphaAmbient.x, PreMulAlphaAmbient.y, PreMulAlphaAmbient.z, 0.000000);
			IfAmbientLight384 = VectorConstruct;
		}
		else
		{
			float3 NoTranslucency = float3(0.000000,0.000000,0.000000);
			float3 _LightPos = GetLightPos(ActiveLightIndex);
			float3 _LightDir = GetLightDir(ActiveLightIndex);
			GetLightVectorOutput GetLightVector848 = GetLightVectorFunction(ActiveLightIndex, _LightPos, PS_IN.WorldPosition.xyz, _LightType, _LightDir);
			float3 LightVecNorm = normalize(GetLightVector848.Result);
			LambertDiffuseOutput LambertDiffuse823 = LambertDiffuseFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, FlippedNormals, LightVecNorm);
			LightContributionOutput LightContribution397 = LightContributionFunction(ActiveLightIndex, PS_IN.WorldPosition.xyz, GetLightVector848.Result);
			float3 AddTranslucency = (NoTranslucency.xyz + (LightContribution397.Light * LambertDiffuse823.Color));
			float3 NormOp1158 = normalize(PS_IN.Tangent.xyz);
			float2 AnisotropicRougness = float2(0.200000, 0.400000);
			float3 AnisotropicColor = float3(1.000000,1.000000,1.000000);
			WardAnisotropicOutput WardAnisotropic1051 = WardAnisotropicFunction(ActiveLightIndex, FlippedNormals, CamVecNorm, LightVecNorm, NormOp1158, AnisotropicRougness, AnisotropicColor.xyz);
			float3 SpecLightIntensity = (WardAnisotropic1051.SpecularColor * LightContribution397.Light);
			float3 Diffuse_Spec = ((ClampOpacity * AddTranslucency) + SpecLightIntensity);
			DesaturateColorOutput DesaturateColor664 = DesaturateColorFunction(ActiveLightIndex, SpecLightIntensity);
			float4 Color_Alpha = float4(Diffuse_Spec.x, Diffuse_Spec.y, Diffuse_Spec.z, DesaturateColor664.DesaturateColor);
			IfAmbientLight384 = Color_Alpha;
		}
		float4 ApplyWeight395 = IfAmbientLight384;
		LightLoopTotal11 += ApplyWeight395;
	}
	float3 NoReflection = float3(0.000000,0.000000,0.000000);
	float3 ReflectXmask = (NoReflection.xyz * 0.000000);
	float3 DefaultEmissiveColor = float3(0.000000,0.000000,0.000000);
	float3 DefaultIBLColor = float3(0.000000,0.000000,0.000000);
	float3 PreMultipliedAlpha = (ClampOpacity * (DefaultEmissiveColor.xyz + DefaultIBLColor.xyz));
	float3 AddReflection = (ReflectXmask + PreMultipliedAlpha);
	DesaturateColorOutput DesaturateColor363 = DesaturateColorFunction(ReflectXmask);
	float OpacityAndReflection = (ClampOpacity + DesaturateColor363.DesaturateColor);
	float4 TotalAmbientAndOpacity = float4(AddReflection.x, AddReflection.y, AddReflection.z, OpacityAndReflection);
	float4 LightLoopAndAfterLoop = (LightLoopTotal11 + TotalAmbientAndOpacity);
	float SatOp = clamp(LightLoopAndAfterLoop.w, 0.0, 1.0);
	float4 VectorConstruct = float4(LightLoopAndAfterLoop.xyz.x, LightLoopAndAfterLoop.xyz.y, LightLoopAndAfterLoop.xyz.z, SatOp);
	outColor = VectorConstruct;
	DepthPeelOutput DepthPeel = DepthPeelFunc(PS_IN.WorldPosition.xyz, view, viewPrj);
	outColor0 = outColor;
	outColor1 = ((outColor0.w > 0.001f ? float4(1.0f, 1.0f, 1.0f, 1.0f) : float4(0.0f, 0.0f, 0.0f, 0.0f)) * DepthPeel.Peel);
}

}

// -------------------------------------- ShaderPixelP3 --------------------------------------
attribute PIXELDATAP3
{
	float4 outColor0 : COLOR0;
	float4 outColor1 : COLOR1;
};

GLSLShader ShaderPixelP3
{
void main(void)
{
	float4 outColor;
	float InvertSatMask = (1.000000 - clamp(0.000000, 0.0, 1.0));
	float3 Color = float3(0.500000,0.500000,0.500000);
	float3 ReplaceDiffuseWithReflection = (Color.xyz * InvertSatMask);
	float3 NormOp = normalize(PS_IN.Normal.xyz);
	float3 FlippedNormals = mix(-(NormOp), NormOp, float(gl_FrontFacing));
	float ClampOpacity = clamp(1.000000, 0.0, 1.0);
	float3 CameraPosition = viewI[3].xyz;
	float3 CamVec = (CameraPosition - PS_IN.WorldPosition.xyz);
	float3 CamVecNorm = normalize(CamVec);
	float4 LightLoopTotal11 = float4(0,0,0,0);
	for (int ActiveLightIndex = 0; ActiveLightIndex < 3; ++ActiveLightIndex)
	{
		if (ActiveLightIndex >= ClampDynamicLights) {continue;}
		int _LightType = GetLightType(ActiveLightIndex);
		bool IsAmbientLight = (_LightType == 5);
		float4 IfAmbientLight384 = float4(0, 0, 0, 0);
		if (IsAmbientLight)
		{
			float3 _LightColor = GetLightColor(ActiveLightIndex);
			float _LightIntensity = GetLightIntensity(ActiveLightIndex);
			AmbientLightOutput AmbientLight389 = AmbientLightFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, _LightColor, _LightIntensity);
			float3 PreMulAlphaAmbient = (ClampOpacity * (AmbientLight389.LightColor * 1.000000));
			float4 VectorConstruct = float4(PreMulAlphaAmbient.x, PreMulAlphaAmbient.y, PreMulAlphaAmbient.z, 0.000000);
			IfAmbientLight384 = VectorConstruct;
		}
		else
		{
			float3 NoTranslucency = float3(0.000000,0.000000,0.000000);
			float3 _LightPos = GetLightPos(ActiveLightIndex);
			float3 _LightDir = GetLightDir(ActiveLightIndex);
			GetLightVectorOutput GetLightVector848 = GetLightVectorFunction(ActiveLightIndex, _LightPos, PS_IN.WorldPosition.xyz, _LightType, _LightDir);
			float3 LightVecNorm = normalize(GetLightVector848.Result);
			LambertDiffuseOutput LambertDiffuse823 = LambertDiffuseFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, FlippedNormals, LightVecNorm);
			LightContributionOutput LightContribution397 = LightContributionFunction(ActiveLightIndex, PS_IN.WorldPosition.xyz, GetLightVector848.Result);
			float3 AddTranslucency = (NoTranslucency.xyz + (LightContribution397.Light * LambertDiffuse823.Color));
			float3 NormOp1158 = normalize(PS_IN.Tangent.xyz);
			float2 AnisotropicRougness = float2(0.200000, 0.400000);
			float3 AnisotropicColor = float3(1.000000,1.000000,1.000000);
			WardAnisotropicOutput WardAnisotropic1051 = WardAnisotropicFunction(ActiveLightIndex, FlippedNormals, CamVecNorm, LightVecNorm, NormOp1158, AnisotropicRougness, AnisotropicColor.xyz);
			float3 SpecLightIntensity = (WardAnisotropic1051.SpecularColor * LightContribution397.Light);
			float3 Diffuse_Spec = ((ClampOpacity * AddTranslucency) + SpecLightIntensity);
			DesaturateColorOutput DesaturateColor664 = DesaturateColorFunction(ActiveLightIndex, SpecLightIntensity);
			float4 Color_Alpha = float4(Diffuse_Spec.x, Diffuse_Spec.y, Diffuse_Spec.z, DesaturateColor664.DesaturateColor);
			IfAmbientLight384 = Color_Alpha;
		}
		float4 ApplyWeight395 = IfAmbientLight384;
		LightLoopTotal11 += ApplyWeight395;
	}
	float3 NoReflection = float3(0.000000,0.000000,0.000000);
	float3 ReflectXmask = (NoReflection.xyz * 0.000000);
	float3 DefaultEmissiveColor = float3(0.000000,0.000000,0.000000);
	float3 DefaultIBLColor = float3(0.000000,0.000000,0.000000);
	float3 PreMultipliedAlpha = (ClampOpacity * (DefaultEmissiveColor.xyz + DefaultIBLColor.xyz));
	float3 AddReflection = (ReflectXmask + PreMultipliedAlpha);
	DesaturateColorOutput DesaturateColor363 = DesaturateColorFunction(ReflectXmask);
	float OpacityAndReflection = (ClampOpacity + DesaturateColor363.DesaturateColor);
	float4 TotalAmbientAndOpacity = float4(AddReflection.x, AddReflection.y, AddReflection.z, OpacityAndReflection);
	float4 LightLoopAndAfterLoop = (LightLoopTotal11 + TotalAmbientAndOpacity);
	float SatOp = clamp(LightLoopAndAfterLoop.w, 0.0, 1.0);
	float4 VectorConstruct = float4(LightLoopAndAfterLoop.xyz.x, LightLoopAndAfterLoop.xyz.y, LightLoopAndAfterLoop.xyz.z, SatOp);
	outColor = VectorConstruct;
	outColor0 = outColor;
	outColor1 = (outColor0.w > 0.001f ? float4(1.0f, 1.0f, 1.0f, 1.0f) : float4(0.0f, 0.0f, 0.0f, 0.0f));
}

}

// -------------------------------------- technique T0 ---------------------------------------
technique T0
<
	string transparency = "opaque";
	string supportsAdvancedTransparency = "true";
>
{
	pass P0
	<
		string drawContext = "colorPass";
	>
	{
		VertexShader (in APPDATA, out SHADERDATA VS_OUT) = { Common_Funcs, VertexShader_Funcs, ShaderVertex};
		PixelShader (in SHADERDATA PS_IN, out PIXELDATA) = { Common_Funcs, PixelShader_Funcs, ShaderPixel};
	}

	pass P1
	<
		string drawContext = "transparentPeel";
	>
	{
		VertexShader (in APPDATA, out SHADERDATA VS_OUT) = { Common_Funcs, VertexShader_Funcs, ShaderVertex};
		PixelShader (in SHADERDATA PS_IN, out PIXELDATAP1) = { Common_Funcs, PixelShader_Funcs, ShaderPixelP1};
	}

	pass P2
	<
		string drawContext = "transparentPeelAndAvg";
	>
	{
		VertexShader (in APPDATA, out SHADERDATA VS_OUT) = { Common_Funcs, VertexShader_Funcs, ShaderVertex};
		PixelShader (in SHADERDATA PS_IN, out PIXELDATAP2) = { Common_Funcs, PixelShader_Funcs, ShaderPixelP2};
	}

	pass P3
	<
		string drawContext = "transparentWeightedAvg";
	>
	{
		VertexShader (in APPDATA, out SHADERDATA VS_OUT) = { Common_Funcs, VertexShader_Funcs, ShaderVertex};
		PixelShader (in SHADERDATA PS_IN, out PIXELDATAP3) = { Common_Funcs, PixelShader_Funcs, ShaderPixelP3};
	}

}

