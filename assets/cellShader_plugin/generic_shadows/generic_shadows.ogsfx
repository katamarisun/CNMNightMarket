#version 410
// ----------------------------------------- Header ------------------------------------------
#ifndef SFX_OGSFX
	#define SFX_OGSFX
#endif 
#ifndef _MAYA_
	#define _MAYA_
#endif 



#define float2 vec2
#define float3 vec3
#define float4 vec4
#define float3x3 mat3
#define float4x4 mat4
#ifdef COMPILING_VS
	#define OUTIN out 
#else 
	#define OUTIN in 
#endif 
#ifndef half 
	#define half float 
	#define half2 float2 
	#define half3 float3 
	#define half4 float4 
#endif 


uniform float2 ShadowFilterTaps[10] = {{-0.840520, -0.073954}, {-0.326235, -0.405830}, {-0.698464, 0.457259}, {-0.203356, 0.620585}, {0.963450, -0.194353}, {0.473434, -0.480026}, {0.519454, 0.767034}, {0.185461, -0.894523}, {0.507351, 0.064963}, {-0.321932, 0.595435}};



// ----------------------------------- Per Frame --------------------------------------
uniform float4x4 viewI : ViewInverse < string UIWidget = "None"; >;

uniform 	bool MayaHwFogEnabled : HardwareFogEnabled < string UIWidget = "None"; > = false; 
uniform 	int MayaHwFogMode : HardwareFogMode < string UIWidget = "None"; > = 0; 
uniform 	float MayaHwFogStart : HardwareFogStart < string UIWidget = "None"; > = 0.0; 
uniform 	float MayaHwFogEnd : HardwareFogEnd < string UIWidget = "None"; > = 100.0; 
uniform 	float MayaHwFogDensity : HardwareFogDensity < string UIWidget = "None"; > = 0.1; 
uniform 	float4 MayaHwFogColor : HardwareFogColor < string UIWidget = "None"; > = { 0.5, 0.5, 0.5, 1.0 }; 


uniform float4x4 viewPrj : ViewProjection < string UIWidget = "None"; >;

uniform float4x4 view : View < string UIWidget = "None"; >;


// --------------------------------------- Per Object -----------------------------------------
uniform float4x4 world : World < string UIWidget = "None"; >;

uniform int ClampDynamicLights
<
	float UIMin = 0;
	float UISoftMin = 0;
	float UIMax = 99;
	float UISoftMax = 99;
	float UIStep = 1;
	string UIName = "ClampDynamicLights";
	string UIWidget = "Slider";
> = 99;

uniform float4x4 wvp : WorldViewProjection < string UIWidget = "None"; >;


// ----------------------------------- Lights --------------------------------------
uniform int KeyLightType : LIGHTTYPE
<
	string UIName =  "Light 0 Type";
	float UIMin = 0;
	float UIMax = 5;
	float UIStep = 1;
	string UIWidget = "None";
	string Object =  "Light 0";
> = 3;

uniform int BounceLightType : LIGHTTYPE
<
	string UIName =  "Light 1 Type";
	float UIMin = 0;
	float UIMax = 5;
	float UIStep = 1;
	string UIWidget = "None";
	string Object =  "Light 1";
> = 3;

uniform int GradientLightType : LIGHTTYPE
<
	string UIName =  "Light 2 Type";
	float UIMin = 0;
	float UIMax = 5;
	float UIStep = 1;
	string UIWidget = "None";
	string Object =  "Light 2";
> = 3;

uniform float3 KeyLightColor : LIGHTCOLOR
<
	string UIName =  "Light 0 Color";
	string UIWidget = "ColorPicker";
	string Object =  "Light 0";
> = {1.0, 1.0, 1.0};

uniform float3 BounceLightColor : LIGHTCOLOR
<
	string UIName =  "Light 1 Color";
	string UIWidget = "ColorPicker";
	string Object =  "Light 1";
> = {1.0, 1.0, 1.0};

uniform float3 GradientLightColor : LIGHTCOLOR
<
	string UIName =  "Light 2 Color";
	string UIWidget = "ColorPicker";
	string Object =  "Light 2";
> = {1.0, 1.0, 1.0};

uniform float KeyLightIntensity : LIGHTINTENSITY
<
	string UIName =  "Light 0 Intensity";
	float UIMin = 0;
	float UIStep = 0.1;
	string Object =  "Light 0";
> = 1.0;

uniform float BounceLightIntensity : LIGHTINTENSITY
<
	string UIName =  "Light 1 Intensity";
	float UIMin = 0;
	float UIStep = 0.1;
	string Object =  "Light 1";
> = 1.0;

uniform float GradientLightIntensity : LIGHTINTENSITY
<
	string UIName =  "Light 2 Intensity";
	float UIMin = 0;
	float UIStep = 0.1;
	string Object =  "Light 2";
> = 1.0;

uniform float3 KeyLightPos : POSITION
<
	string UIName =  "Light 0 Position";
	string Space = "World";
	string Object =  "Light 0";
> = {1.0, 1.0, 1.0};

uniform float3 BounceLightPos : POSITION
<
	string UIName =  "Light 1 Position";
	string Space = "World";
	string Object =  "Light 1";
> = {1.0, 1.0, 1.0};

uniform float3 GradientLightPos : POSITION
<
	string UIName =  "Light 2 Position";
	string Space = "World";
	string Object =  "Light 2";
> = {1.0, 1.0, 1.0};

uniform float3 KeyLightDir : DIRECTION
<
	string UIName =  "Light 0 Direction";
	string Space = "World";
	string Object =  "Light 0";
> = {0.0, -1.0, 0.0};

uniform float3 BounceLightDir : DIRECTION
<
	string UIName =  "Light 1 Direction";
	string Space = "World";
	string Object =  "Light 1";
> = {0.0, -1.0, 0.0};

uniform float3 GradientLightDir : DIRECTION
<
	string UIName =  "Light 2 Direction";
	string Space = "World";
	string Object =  "Light 2";
> = {0.0, -1.0, 0.0};

uniform float KeyLightAttenuation : DECAYRATE
<
	string UIName =  "Light 0 Decay";
	float UIMin = 0;
	float UIStep = 1;
	string Object =  "Light 0";
> = 0.000000;

uniform float BounceLightAttenuation : DECAYRATE
<
	string UIName =  "Light 1 Decay";
	float UIMin = 0;
	float UIStep = 1;
	string Object =  "Light 1";
> = 0.000000;

uniform float GradientLightAttenuation : DECAYRATE
<
	string UIName =  "Light 2 Decay";
	float UIMin = 0;
	float UIStep = 1;
	string Object =  "Light 2";
> = 0.000000;

uniform float KeyLightConeAngle : HOTSPOT
<
	string UIName =  "Light 0 ConeAngle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Space = "World";
	string Object =  "Light 0";
> = 0.46;

uniform float BounceLightConeAngle : HOTSPOT
<
	string UIName =  "Light 1 ConeAngle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Space = "World";
	string Object =  "Light 1";
> = 0.46;

uniform float GradientLightConeAngle : HOTSPOT
<
	string UIName =  "Light 2 ConeAngle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Space = "World";
	string Object =  "Light 2";
> = 0.46;

uniform float KeyLightFalloff : FALLOFF
<
	string UIName =  "Light 0 Penumbra Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Object =  "Light 0";
> = 0.7;

uniform float BounceLightFalloff : FALLOFF
<
	string UIName =  "Light 1 Penumbra Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Object =  "Light 1";
> = 0.7;

uniform float GradientLightFalloff : FALLOFF
<
	string UIName =  "Light 2 Penumbra Angle";
	float UIMin = 0;
	float UIMax = 1.571;
	float UIStep = 0.05;
	string Object =  "Light 2";
> = 0.7;

uniform bool KeyLightShadowOn : SHADOWFLAG
<
	string UIName =  "Light 0 Shadow";
	string Object =  "Light 0";
> = true;

uniform bool BounceLightShadowOn : SHADOWFLAG
<
	string UIName =  "Light 1 Shadow";
	string Object =  "Light 1";
> = true;

uniform bool GradientLightShadowOn : SHADOWFLAG
<
	string UIName =  "Light 2 Shadow";
	string Object =  "Light 2";
> = true;

uniform float4x4 KeyLightViewPrj : SHADOWMAPMATRIX
<
	string Object =  "Light 0";
	string UIName =  "Light 0 Matrix";
	string UIWidget = "None";
	int LightRef = 1;
>;

uniform float4x4 BounceLightViewPrj : SHADOWMAPMATRIX
<
	string Object =  "Light 1";
	string UIName =  "Light 1 Matrix";
	string UIWidget = "None";
	int LightRef = 2;
>;

uniform float4x4 GradientLightViewPrj : SHADOWMAPMATRIX
<
	string Object =  "Light 2";
	string UIName =  "Light 2 Matrix";
	string UIWidget = "None";
	int LightRef = 3;
>;

uniform float KeyLightShadowBias : SHADOWBIAS
<
	string UIName =  "Light 0 Shadow Bias";
	string Object =  "Light 0";
> = 0.01;

uniform float BounceLightShadowBias : SHADOWBIAS
<
	string UIName =  "Light 1 Shadow Bias";
	string Object =  "Light 1";
> = 0.01;

uniform float GradientLightShadowBias : SHADOWBIAS
<
	string UIName =  "Light 2 Shadow Bias";
	string Object =  "Light 2";
> = 0.01;

uniform float3 KeyLightShadowColor : SHADOWCOLOR
<
	string UIName =  "Light 0 Shadow Color";
	string Object =  "Light 0";
> = {0, 0, 0};

uniform float3 BounceLightShadowColor : SHADOWCOLOR
<
	string UIName =  "Light 1 Shadow Color";
	string Object =  "Light 1";
> = {0, 0, 0};

uniform float3 GradientLightShadowColor : SHADOWCOLOR
<
	string UIName =  "Light 2 Shadow Color";
	string Object =  "Light 2";
> = {0, 0, 0};

    
uniform bool use_tex
<
    string UIName = "Toggle Texture";
    string UIGroup = "Base Color";
> = 0.0;

uniform texture2D diffuse_color_tex <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Diffuse Texture";
    string UIGroup = "Base Color";
>;

uniform vec4 diffuseColor
    <
    string UIName = "Diffuse Color";
    string UIWidget = "Color";
    string UIGroup = "Base Color";
> = {0.5, 0.5, 0.5, 1.0f};


uniform float darken_base
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Darken Base";
    string UIGroup = "Base Color";
> = 0.0;

uniform bool use_light_mask
<
    string UIName = "Use Light Mask";
    string UIGroup = "Base Color";
> = 0.0;

uniform texture2D light_mask <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Light Mask";
    string UIGroup = "Base Color";
>;

uniform float kCutoff
<
    string UIWidget = "slider";
    float UIMin = -10.0;
    float UIMax = 10.0;
    float UIStep = 0.01;
    string UIName = "Normal Cutoff";
    string UIGroup = "Key Light";
> = 0.4;

uniform float kSoftness
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Key Softness";
    string UIGroup = "Key Light";
> = 0.0;

uniform vec4 kLightColor
<
    string UIName = "Key Light Color";
    string UIWidget = "Color";
    string UIGroup = "Key Light";

> = {0.6, 0.6, 0.6, 1.0f};

uniform float kLightBlend
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 8.0;
    float UIStep = 1.0;
    string UIName = "Light Blending Mode";
    string UIGroup = "Key Light";
> = 1.0;

uniform float kLightOpacity
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.1;
    string UIName = "Light Opacity";
    string UIGroup = "Key Light";
> = 1.0;

uniform vec4 kShadowColor
<
    string UIName = "Key Shadow Color";
    string UIWidget = "Color";
    string UIGroup = "Key Light";
> = {0.2, 0.2, 0.2, 1.0f};

uniform float kShadowBlend
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 8.0;
    float UIStep = 1.0;
    string UIName = "Shadow Blending Mode";
    string UIGroup = "Key Light";
> = 1.0;

uniform float kShadowOpacity
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.1;
    string UIName = "Shadow Opacity";
    string UIGroup = "Key Light";
> = 1.0;

uniform bool kplaneGrad
<
    string UIName = "Toggle Plane/Normal";
    string UIGroup = "Key Light";
> = 0.0;

uniform float kXPos
<
    string UIWidget = "slider";
    float UIMin = -1.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Key X Position";
    string UIGroup = "Key Light";
> = 0.1;

uniform float kYPos
<
    string UIWidget = "slider";
    float UIMin = -1.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Key Y Position";
    string UIGroup = "Key Light";
> = 1.0;

uniform float kZPos
<
    string UIWidget = "slider";
    float UIMin = -1.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Key Z Position";
    string UIGroup = "Key Light";
> = 0.1;

uniform bool bplaneGrad
<
    string UIName = "Toggle Plane/Normal";
    string UIGroup = "Gradients";
> = 1.0;

uniform bool affectShadow
<
    string UIName = "Affect Shadow Side";
    string UIGroup = "Gradients";
> = 1;

uniform bool affectLight
<
    string UIName = "Affect Light Side";
    string UIGroup = "Gradients";
> = 0;

uniform float bCutoff
<
    string UIWidget = "slider";
    float UIMin = -1.0;
    float UIMax = 2.0;
    float UIStep = 0.01;
    string UIName = "Gradient Cutoff";
    string UIGroup = "Gradients";
> = 0.1;

uniform float bSoftness
<
    string UIWidget = "slider";
    float UIMin = 0.01;
    float UIMax = 2.0;
    float UIStep = 0.01;
    string UIName = "Gradient Softness";
    string UIGroup = "Gradients";
> = 0.5;

uniform vec4 bLightColor
    <
    string UIName = "Gradient Color1";
    string UIWidget = "Color";
    string UIGroup = "Gradients";
> = {0.5, 0.5, 0.5, 1.0f};

uniform float bLightBlend
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 8.0;
    float UIStep = 1.0;
    string UIName = "Color1 Blending Mode";
    string UIGroup = "Gradients";
> = 1.0;

uniform float bLightOpacity
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.1;
    string UIName = "Color1 Opacity";
    string UIGroup = "Gradients";
> = 1.0;

uniform vec4 bShadowColor
<
    string UIName = "Gradient Color2";
    string UIWidget = "Color";
    string UIGroup = "Gradients";
> = {0.5, 0.5, 0.5, 1.0f};

uniform float bShadowBlend
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 8.0;
    float UIStep = 1.0;
    string UIName = "Color2 Blending Mode";
    string UIGroup = "Gradients";
> = 1.1;

uniform float bShadowOpacity
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.1;
    string UIName = "Color2 Opacity";
    string UIGroup = "Gradients";
> = 1.0;


uniform float bXPos
<
    string UIWidget = "slider";
    float UIMin = -1.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "X Position";
    string UIGroup = "Gradients";
> = -0.1;

uniform float bYPos
<
    string UIWidget = "slider";
    float UIMin = -1.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Y Position";
    string UIGroup = "Gradients";
> = 0.0;

uniform float bZPos
<
    string UIWidget = "slider";
    float UIMin = -1.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Z Position";
    string UIGroup = "Gradients";
> = -0.5;

uniform sampler2D gStripeSampler
    = sampler_state {
    Texture = <diffuse_color_tex>;
};

uniform sampler2D light_mask_sampler
    = sampler_state {
    Texture = <light_mask>;
} ;

uniform bool use_ao
<
    string UIName = "Use Ambient Oclusion";
    string UIGroup = "Ambient Oclusion";
> = 0.0;

uniform float ao_opacity
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "AO Opacity";
    string UIGroup = "Ambient Oclusion";
> = 1.0;

uniform texture2D ambient_oclusion <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Ambient Oclusion";
    string UIGroup = "Ambient Oclusion";
>;

uniform sampler2D oclusion_sampler
    = sampler_state {
    Texture = <ambient_oclusion>;
};


uniform bool use_presence
<
    string UIName = "Use Presence Map";
    string UIGroup = "Appearance";
> = 0.0;


uniform texture2D presence_map <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Presence Map";
    string UIGroup = "Appearance";
>;

uniform sampler2D presence_sampler
    = sampler_state {
    Texture = <presence_map>;
};

uniform float masterOpacity
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Master Opacity";
    string UIGroup = "Appearance";
> = 1.0;

uniform bool use_opacity
<
    string UIName = "Use Opacity Map";
    string UIGroup = "Appearance";
> = 0.0;


uniform texture2D opacity_map <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Opacity Map";
    string UIGroup = "Appearance";
>;

uniform sampler2D opacity_sampler
    = sampler_state {
    Texture = <opacity_map>;
};

uniform bool use_normal
#if OGSFX
<
    string UIName = "Use Normal Map";
    string UIGroup = "Normals and Displacement";
>
#endif
    = 0;

uniform texture2D normalMap <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Normal Map";
    string UIGroup = "Normals and Displacement";
>;

uniform sampler2D normalSampler
    = sampler_state {
    Texture = <normalMap>;
};

uniform bool use_disp
<
    string UIName = "Use Displacement Map";
    string UIGroup = "Normals and Displacement";
> = 0;

uniform float constDisplacement
<
    string UIWidget = "slider";
    float UIMin = -1.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Constant Displacement";
    string UIGroup = "Normals and Displacement";
> = 0.0;

uniform texture2D dispMap <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Displacement Map";
    string UIGroup = "Normals and Displacement";
>;

uniform sampler2D dispSampler
    = sampler_state {
    Texture = <dispMap>;
};

uniform float objWorldOffsetX
<
    string UIName = "Object World Position X";
    string UIGroup = "Fudge";
> = 0.0;

uniform float objWorldOffsetY
<
    string UIName = "Object World Position Y";
    string UIGroup = "Fudge";
> = 0.0;

uniform float objWorldOffsetZ
<
    string UIName = "Object World Position Z";
    string UIGroup = "Fudge";
> = 0.0;

uniform float fudgeNormalHeight
<
    string UIWidget = "slider";
    float UIMin = -3.00;
    float UIMax = 3.0;
    float UIStep = 0.01;
    string UIName = "Normal Height Fudge";
    string UIGroup = "Fudge";
> = 1.0;

uniform float lightMaskFudge
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 0.5;
    float UIStep = 0.01;
    string UIName = "Light Mask Fudge";
    string UIGroup = "Fudge";
> = 0.5;

uniform vec4 eyeBrowColor
<
    string UIName = "Eyebrow Color";
    string UIWidget = "Color";
    string UIGroup = "Fudge";
> = {0.2, 0.2, 0.2, 1.0f};

// ---------------------------------------- Textures -----------------------------------------
uniform texture2D KeyLightShadowMap : SHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "2D";
	string UIWidget = "None";
	string Object =  "Light 0";
>;

uniform texture2D BounceLightShadowMap : SHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "2D";
	string UIWidget = "None";
	string Object =  "Light 1";
>;

uniform texture2D GradientLightShadowMap : SHADOWMAP
<
	string ResourceName = "";
	string ResourceType = "2D";
	string UIWidget = "None";
	string Object =  "Light 2";
>;

uniform sampler2D KeyLightShadowMapSampler = sampler_state 
{
	Texture = <KeyLightShadowMap>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};

uniform sampler2D BounceLightShadowMapSampler = sampler_state 
{
	Texture = <BounceLightShadowMap>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};

uniform sampler2D GradientLightShadowMapSampler = sampler_state 
{
	Texture = <GradientLightShadowMap>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};

uniform texture2D TransDepthTexture : transpdepthtexture
<
	string ResourceName = "";
	string UIName = "TransDepthTexture";
	string ResourceType = "2D";
	string UIWidget = "None";
>;

uniform texture2D OpaqueDepthTexture : opaquedepthtexture
<
	string ResourceName = "";
	string UIName = "OpaqueDepthTexture";
	string ResourceType = "2D";
	string UIWidget = "None";
>;

uniform sampler2D TransDepthTextureSampler = sampler_state 
{
	Texture = <TransDepthTexture>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};

uniform sampler2D OpaqueDepthTextureSampler = sampler_state 
{
	Texture = <OpaqueDepthTexture>;
	TEXTURE_MIN_FILTER = NEAREST;
	TEXTURE_MAG_FILTER = NEAREST;
	TEXTURE_WRAP_S = REPEAT;
	TEXTURE_WRAP_T = REPEAT;
	TEXTURE_WRAP_R = REPEAT;
};


GLSLShader Common_Funcs
{
}

GLSLShader VertexShader_Funcs
{
}

GLSLShader GeometryShader_Funcs
{
}

GLSLShader PixelShader_Funcs
{
int GetLightType(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightType; 
	else if (ActiveLightIndex == 1) 
		return BounceLightType; 
	else 
		return GradientLightType; 
}

float3 GetLightColor(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightColor; 
	else if (ActiveLightIndex == 1) 
		return BounceLightColor; 
	else 
		return GradientLightColor; 
}

float GetLightIntensity(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightIntensity; 
	else if (ActiveLightIndex == 1) 
		return BounceLightIntensity; 
	else 
		return GradientLightIntensity; 
}

float3 GetLightPos(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightPos; 
	else if (ActiveLightIndex == 1) 
		return BounceLightPos; 
	else 
		return GradientLightPos; 
}

float3 GetLightDir(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightDir; 
	else if (ActiveLightIndex == 1) 
		return BounceLightDir; 
	else 
		return GradientLightDir; 
}

float GetLightAttenuation(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightAttenuation; 
	else if (ActiveLightIndex == 1) 
		return BounceLightAttenuation; 
	else 
		return GradientLightAttenuation; 
}

float GetLightConeAngle(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightConeAngle; 
	else if (ActiveLightIndex == 1) 
		return BounceLightConeAngle; 
	else 
		return GradientLightConeAngle; 
}

float GetLightFalloff(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightFalloff; 
	else if (ActiveLightIndex == 1) 
		return BounceLightFalloff; 
	else 
		return GradientLightFalloff; 
}

bool GetLightShadowOn(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightShadowOn; 
	else if (ActiveLightIndex == 1) 
		return BounceLightShadowOn; 
	else 
		return GradientLightShadowOn; 
}

float4x4 GetLightViewPrj(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightViewPrj; 
	else if (ActiveLightIndex == 1) 
		return BounceLightViewPrj; 
	else 
		return GradientLightViewPrj; 
}

float GetLightShadowBias(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightShadowBias; 
	else if (ActiveLightIndex == 1) 
		return BounceLightShadowBias; 
	else 
		return GradientLightShadowBias; 
}

float4 SampleFromShadowMap( int ActiveLightIndex, float2 UVs) 
{ 
	if (ActiveLightIndex == 0) 
		return textureLod(KeyLightShadowMapSampler, UVs, 0); 
	else if (ActiveLightIndex == 1) 
		return textureLod(BounceLightShadowMapSampler, UVs, 0); 
	else 
		return textureLod(GradientLightShadowMapSampler, UVs, 0); 
}

float3 GetLightShadowColor(int ActiveLightIndex) 
{ 
	if (ActiveLightIndex == 0) 
		return KeyLightShadowColor; 
	else if (ActiveLightIndex == 1) 
		return BounceLightShadowColor; 
	else 
		return GradientLightShadowColor; 
}

float4 sampleTransDepthTex(float2 UV)
{
	float4 col = float4(0,0,0,0);

	#if defined(SFX_CGFX_3) || defined(SFX_HLSL_3)
		col = tex2D( TransDepthTextureSampler, UV );
	#endif
	#ifdef SFX_HLSL_5
		#if defined(SFX_SWATCH) || defined(_3DSMAX_)
			col = TransDepthTexture.Sample( TransDepthTextureSampler, UV );
		#else
			col = TransDepthTexture.Sample( TransDepthTextureSampler, UV );
		#endif
	#endif
	#ifdef SFX_GLSL_4
		col = texture( TransDepthTexture, UV );
	#endif
	#ifdef SFX_OGSFX
		col = texture( TransDepthTextureSampler, UV );
	#endif
	#ifdef SFX_GLSL_1_2
		col = texture2D( TransDepthTexture, UV );
	#endif

	return col;
}

float4 sampleOpaqueDepthTex(float2 UV)
{
	float4 col = float4(0,0,0,0);

	#if defined(SFX_CGFX_3) || defined(SFX_HLSL_3)
		col = tex2D( OpaqueDepthTextureSampler, UV );
	#endif
	#ifdef SFX_HLSL_5
		#if defined(SFX_SWATCH) || defined(_3DSMAX_)
			col = OpaqueDepthTexture.Sample( OpaqueDepthTextureSampler, UV );
		#else
			col = OpaqueDepthTexture.Sample( OpaqueDepthTextureSampler, UV );
		#endif
	#endif
	#ifdef SFX_GLSL_4
		col = texture( OpaqueDepthTexture, UV );
	#endif
	#ifdef SFX_OGSFX
		col = texture( OpaqueDepthTextureSampler, UV );
	#endif
	#ifdef SFX_GLSL_1_2
		col = texture2D( OpaqueDepthTexture, UV );
	#endif

	return col;
}

struct DepthPeelOutput 
{ 
	float4 LinearDepth; 
	float Peel;
}; 

DepthPeelOutput DepthPeelFunc( float3 worldPos, float4x4 view, float4x4 viewPrj ) 
{ 
	DepthPeelOutput OUT; 

	#ifdef SFX_CGFX_3
		float currZ = abs( mul( view, float4(worldPos, 1.0f) ).z );
		float4 Pndc  = mul( viewPrj, float4(worldPos, 1.0f) );
		float2 UV = Pndc.xy / Pndc.w * float2(0.5f, 0.5f) + 0.5f;

		float prevZ = sampleTransDepthTex(UV).r;
		float opaqZ = sampleOpaqueDepthTex(UV).r;
		float bias = 0.00002f;
		if (currZ < prevZ * (1.0f + bias) || currZ > opaqZ * (1.0f - bias))
		{
			discard;
		}

		float ld = abs( mul( view, float4(worldPos, 1.0f) ).z );
		OUT.LinearDepth = float4(ld, ld, ld, ld);
	#else
	#if defined(SFX_GLSL_1_2) || defined(SFX_GLSL_4) || defined(SFX_OGSFX)
		float currZ = abs( ( view * float4(worldPos, 1.0f) ).z );
		float4 Pndc  = viewPrj * float4(worldPos, 1.0f);
		float2 UV = Pndc.xy / Pndc.w * float2(0.5f, 0.5f) + 0.5f;

		float prevZ = sampleTransDepthTex(UV).r;
		float opaqZ = sampleOpaqueDepthTex(UV).r;
		float bias = 0.00002f;
		if (currZ < prevZ * (1.0f + bias) || currZ > opaqZ * (1.0f - bias))
		{
			discard;
		}

		float ld = abs( ( view * float4(worldPos, 1.0f) ).z );
		OUT.LinearDepth = float4(ld, ld, ld, ld);
	#else
		float currZ = abs( mul( float4(worldPos, 1.0f), view ).z );
		float4 Pndc  = mul( float4(worldPos, 1.0f), viewPrj );
		float2 UV = Pndc.xy / Pndc.w * float2(0.5f, -0.5f) + 0.5f;

		float prevZ = sampleTransDepthTex(UV).r;
		float opaqZ = sampleOpaqueDepthTex(UV).r;
		float bias = 0.00002f;
		if (currZ < prevZ * (1.0f + bias) || currZ > opaqZ * (1.0f - bias))
		{
			discard;
		}

		float ld = abs( mul( float4(worldPos, 1.0f), view ).z );
		OUT.LinearDepth = float4(ld, ld, ld, ld);
#endif
	#endif

	OUT.Peel = 1.0f;

	return OUT; 
} 


// -------------------------------------- AmbientLightFunction --------------------------------------
struct AmbientLightOutput
{
	float3 LightColor;
};

AmbientLightOutput AmbientLightFunction(int ActiveLightIndex, float3 AlbedoColor, float3 LightColor, float LightIntensity)
{
	AmbientLightOutput OUT;

	float3 MulOp = ((LightColor * AlbedoColor) * LightIntensity);
	OUT.LightColor = MulOp;

	return OUT;
}

// -------------------------------------- GetLightVectorFunction --------------------------------------
struct GetLightVectorOutput
{
	float3 Result;
};

GetLightVectorOutput GetLightVectorFunction(int ActiveLightIndex, float3 LightPosition, float3 VertexWorldPosition, int LightType, float3 LightDirection)
{
	GetLightVectorOutput OUT;

	bool IsDirectionalLight = (LightType == 4);
	float3 LerpOp = mix((LightPosition - VertexWorldPosition), -(LightDirection), float(IsDirectionalLight));
	OUT.Result = LerpOp;

	return OUT;
}

// -------------------------------------- calc_alpha
// --------------------------------------
struct CalcAlphaOutput
{
	float alpha;
};

CalcAlphaOutput calc_alpha( float softness, float cutoff, float cos )
{
	CalcAlphaOutput OUT;

    float lower_bound = cutoff - softness;
    float upper_bound = cutoff + softness;
    float result_alpha = 0;
    if (cos < lower_bound) {
        result_alpha = 0.0;
    } else {
        if (cos > upper_bound) {
            result_alpha = 1.0;
        } else {
            result_alpha = ( cos - lower_bound ) / ( 2 * softness );
        }
    }
    OUT.alpha = result_alpha;
    return OUT;
}

// -------------------------------------- LightDecayFunction --------------------------------------
struct LightDecayOutput
{
	float Attenuation;
};

LightDecayOutput LightDecayFunction(int ActiveLightIndex, float3 LightVectorUN, float Attenuation)
{
	LightDecayOutput OUT;

	bool IsAttenuationUsed = (Attenuation > 0.001000);
	float DecayContribution463 = 0.0;
	if (IsAttenuationUsed)
	{
		float PowOp = pow(length(LightVectorUN), Attenuation);
		float DivOp = (1.000000 / PowOp);
		DecayContribution463 = DivOp;
	}
	else
	{
		DecayContribution463 = 1.000000;
	}
	OUT.Attenuation = DecayContribution463;

	return OUT;
}

// -------------------------------------- LightConeAngleFunction --------------------------------------
struct LightConeAngleOutput
{
	float ConeAngle;
};

LightConeAngleOutput LightConeAngleFunction(int ActiveLightIndex, float3 LightVector, float3 LightDirection, float ConeAngle, float ConeFalloff)
{
	LightConeAngleOutput OUT;

	float CosOp = cos(max(ConeFalloff, ConeAngle));
	float DotOp = dot(LightVector, -(LightDirection));
	float SmoothStepOp = smoothstep(CosOp, cos(ConeAngle), DotOp);
	OUT.ConeAngle = SmoothStepOp;

	return OUT;
}

// -------------------------------------- ShadowMapFunction --------------------------------------
struct ShadowMapOutput
{
	float LightGain;
};

ShadowMapOutput ShadowMapFunction(int ActiveLightIndex, float4x4 LightViewPrj, float ShadowMapBias, float3 VertexWorldPosition)
{
	ShadowMapOutput OUT;

	float IfElseOp546 = 0.0;
	float4 VectorConstruct = float4(VertexWorldPosition.x, VertexWorldPosition.y, VertexWorldPosition.z, 1.000000);
	float4 MulOp = (LightViewPrj * VectorConstruct);
	float3 DivOp = (MulOp.xyz / MulOp.w);
	if (DivOp.x > -1.000000 && DivOp.x < 1.000000 && DivOp.y > -1.000000 && DivOp.y < 1.000000 && DivOp.z > 0.000000 && DivOp.z < 1.000000)
	{
		float Val = 0.500000;
		float2 AddOp = ((Val * DivOp.xy) + Val);
		float SubOp = (DivOp.z - (ShadowMapBias / MulOp.w));
		float ShadowTotal = 0.000000;
		for(int i=0; i<10; i+=1)
		{
			float2 MulOp586 = (0.000900 * ShadowFilterTaps[i]);
			float2 AddOp587 = (AddOp + MulOp586);
			float4 Sampler = SampleFromShadowMap(ActiveLightIndex, AddOp587);
			float IfElseOp540 = ((SubOp - Sampler.x) >= 0.000000) ? (0.000000) : (0.100000);
			ShadowTotal += IfElseOp540;
		}
		IfElseOp546 = ShadowTotal;
	}
	else
	{
		IfElseOp546 = 1.000000;
	}
	OUT.LightGain = IfElseOp546;

	return OUT;
}

// -------------------------------------- LightContributionFunction --------------------------------------
struct LightContributionOutput
{
	float Light;
};

LightContributionOutput LightContributionFunction(int ActiveLightIndex, float3 VertexWorldPosition, float3 LightVectorUN)
{
	LightContributionOutput OUT;

	float _LightIntensity = GetLightIntensity(ActiveLightIndex);
	int _LightType = GetLightType(ActiveLightIndex);
	bool IsDirectionalLight = (_LightType == 4);
	float DecayMul509 = 0.0;
	if (IsDirectionalLight)
	{
		DecayMul509 = 1.000000;
	}
	else
	{
		float _LightAttenuation = GetLightAttenuation(ActiveLightIndex);
		LightDecayOutput LightDecay457 = LightDecayFunction(ActiveLightIndex, LightVectorUN, _LightAttenuation);
		DecayMul509 = LightDecay457.Attenuation;
	}
	bool IsSpotLight = (_LightType == 2);
	float ConeMul511 = 1.000000;
	if (IsSpotLight)
	{
		float3 NormOp = normalize(LightVectorUN);
		float3 _LightDir = GetLightDir(ActiveLightIndex);
		float _LightConeAngle = GetLightConeAngle(ActiveLightIndex);
		float _LightFalloff = GetLightFalloff(ActiveLightIndex);
		LightConeAngleOutput LightConeAngle399 = LightConeAngleFunction(ActiveLightIndex, NormOp, _LightDir, _LightConeAngle, _LightFalloff);
		ConeMul511 = LightConeAngle399.ConeAngle;
	}
	bool _LightShadowOn = GetLightShadowOn(ActiveLightIndex);
	float ShadowMul512 = 1.000000;
	if (_LightShadowOn)
	{
		float4x4 _LightViewPrj = GetLightViewPrj(ActiveLightIndex);
		float _LightShadowBias = GetLightShadowBias(ActiveLightIndex);
		ShadowMapOutput ShadowMap525 = ShadowMapFunction(ActiveLightIndex, _LightViewPrj, _LightShadowBias, VertexWorldPosition);
		ShadowMul512 = ShadowMap525.LightGain;
	}
	float DecayShadowConeMul = ((ShadowMul512 * ConeMul511) * DecayMul509);
	float MulItensity = ((DecayShadowConeMul) * _LightIntensity);
	OUT.Light = MulItensity;

	return OUT;
}

// -------------------------------------- BlinnSpecularFunction --------------------------------------
struct BlinnSpecularOutput
{
	float3 SpecularColor;
};

BlinnSpecularOutput BlinnSpecularFunction(int ActiveLightIndex, float3 LightVector, float3 Normal, float3 CameraVector, float SpecularPower, float3 SpecularColor)
{
	BlinnSpecularOutput OUT;

	float3 NormOp = normalize((LightVector + CameraVector));
	float SatOp = clamp(dot(Normal, NormOp), 0.0, 1.0);
	float3 BlinnSpec = (SpecularColor * pow(SatOp, SpecularPower));
	float SatOp978 = clamp(dot(Normal, LightVector), 0.0, 1.0);
	float3 MulOp = (SatOp978 * BlinnSpec);
	OUT.SpecularColor = MulOp;

	return OUT;
}

// -------------------------------------- DesaturateColorFunction --------------------------------------
struct DesaturateColorOutput
{
	float DesaturateColor;
};

DesaturateColorOutput DesaturateColorFunction(int ActiveLightIndex, float3 Color)
{
	DesaturateColorOutput OUT;

	float3 Col = float3(0.300008,0.600000,0.100008);
	float DotOp = dot(clamp(Color, 0.0, 1.0), Col.xyz);
	OUT.DesaturateColor = DotOp;

	return OUT;
}

// -------------------------------------- DesaturateColorFunction --------------------------------------
DesaturateColorOutput DesaturateColorFunction(float3 Color)
{
	DesaturateColorOutput OUT;

	float3 Col = float3(0.300008,0.600000,0.100008);
	float DotOp = dot(clamp(Color, 0.0, 1.0), Col.xyz);
	OUT.DesaturateColor = DotOp;

	return OUT;
}

}

// -------------------------------------- ShaderVertex --------------------------------------
attribute APPDATA
{
	float3 inPosition : POSITION;
	float3 inNormal : NORMAL;
	vec2 UV : TEXCOORD0;
};

attribute SHADERDATA
{
	float4 Normal : NORMAL;
	float4 WorldPosition : TEXCOORD0;
	half3 FogFactor : TEXCOORD1;
	vec2 fUV : TEXCOORD2;
};

GLSLShader ShaderVertex
{
void main(void)
{
	gl_Position = float4(inPosition, 1);
	float3 MulOp = ((float3x3(world)) * inNormal);
	float3 NormalN = normalize(MulOp);
	float4 WorldNormal = float4(NormalN.x, NormalN.y, NormalN.z, 1.000000);
	VS_OUT.Normal = WorldNormal;
	float4 WorldPos = (world * gl_Position);
	VS_OUT.WorldPosition = WorldPos;
	VS_OUT.WorldPosition = (world * float4(inPosition, 1));
	float4 _HPosition = mul( viewPrj, float4(VS_OUT.WorldPosition.xyz, 1) ); 
	float fogFactor = 0.0; 
	if (MayaHwFogMode == 0) { 
				fogFactor = saturate((MayaHwFogEnd - _HPosition.z) / (MayaHwFogEnd - MayaHwFogStart)); 
	} 
	else if (MayaHwFogMode == 1) { 
				fogFactor = 1.0 / (exp(_HPosition.z * MayaHwFogDensity)); 
	} 
	else if (MayaHwFogMode == 2) { 
				fogFactor = 1.0 / (exp(pow(_HPosition.z * MayaHwFogDensity, 2))); 
	} 
	VS_OUT.FogFactor = float3(fogFactor, fogFactor, fogFactor); 
	VS_OUT.fUV = vec2(UV[0], 1.0-UV[1]);
	float4 WVSpace = (wvp * gl_Position);
	gl_Position = WVSpace;
}

}

// -------------------------------------- ShaderPixel --------------------------------------
attribute PIXELDATA
{
	float4 outColor : COLOR0;
};

GLSLShader ShaderPixel
{
void main(void)
{
	float InvertSatMask = (1.000000 - clamp(0.000000, 0.0, 1.0));
	vec4 surfaceColor = diffuseColor;
    if (use_tex) {
        surfaceColor = texture2D(gStripeSampler, PS_IN.fUV);  
    }
    float3 Color = float3(surfaceColor[0], surfaceColor[1], surfaceColor[2] );
	float3 ReplaceDiffuseWithReflection = (Color.xyz * InvertSatMask);
	float3 NormOp = normalize(PS_IN.Normal.xyz);
	float3 FlippedNormals = mix(-(NormOp), NormOp, float(gl_FrontFacing));
	float ClampOpacity = clamp(1.000000, 0.0, 1.0);
	float3 CameraPosition = viewI[3].xyz;
	float3 CamVec = (CameraPosition - PS_IN.WorldPosition.xyz);
	float3 CamVecNorm = normalize(CamVec);
	float4 LightLoopTotal11 = float4(0,0,0,0);

	float bounce_mask;
    float key_mask;

    vec4 final_key_shadow = key_shadow;
    vec4 final_key_light = key_light;

    //---------------------------------------------
    int ActiveLightIndex = 0;
	int _LightType = GetLightType(ActiveLightIndex);

	float3 NoTranslucency = float3(0.000000,0.000000,0.000000);
	float3 _LightPos = GetLightPos(ActiveLightIndex);
	float3 _LightDir = GetLightDir(ActiveLightIndex);

	GetLightVectorOutput GetLightVector = GetLightVectorFunction(ActiveLightIndex, _LightPos, PS_IN.WorldPosition.xyz, _LightType, _LightDir);

	float3 KeyLightVecNorm = normalize(GetLightVector.Result);
	float key_intensity = dot(normalize(FlippedNormals), KeyLightVecNorm);

	float key_mask = calc_alpha( kSoftness, kCutoff, key_intensity ).alpha;
	float key_light_intensity = LightContributionFunction(ActiveLightIndex, PS_IN.WorldPosition.xyz, GetLightVector.Result).light;

	key_mask = key_mask * key_light_intensity;

	float3 Col = float3(1.000000,1.000000,1.000000);

	float3 keyBlinnSpec = BlinnSpecularFunction(ActiveLightIndex, LightVecNorm, FlippedNormals, CamVecNorm, 20.000000, Col.xyz).specularColor;

	float3 SpecLightIntensity = (keyBlinnSpec * key_light_intensity);

	colorOut = key_mask * final_key_light + (1.0 - key_mask) * (final_key_shadow);

    /*---------------------------------------------

	for (int ActiveLightIndex = 0; ActiveLightIndex < 3; ++ActiveLightIndex)
	{
		if (ActiveLightIndex >= ClampDynamicLights) {continue;}
		int _LightType = GetLightType(ActiveLightIndex);
		bool IsAmbientLight = (_LightType == 5);
		float4 IfAmbientLight384 = float4(0, 0, 0, 0);
		if (IsAmbientLight)
		{
			float3 _LightColor = GetLightColor(ActiveLightIndex);
			float _LightIntensity = GetLightIntensity(ActiveLightIndex);
			AmbientLightOutput AmbientLight389 = AmbientLightFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, _LightColor, _LightIntensity);
			float3 PreMulAlphaAmbient = (ClampOpacity * (AmbientLight389.LightColor * 1.000000));
			float4 VectorConstruct = float4(PreMulAlphaAmbient.x, PreMulAlphaAmbient.y, PreMulAlphaAmbient.z, 0.000000);
			IfAmbientLight384 = VectorConstruct;
		}
		else
		{
			float3 NoTranslucency = float3(0.000000,0.000000,0.000000);
			float3 _LightPos = GetLightPos(ActiveLightIndex);
			float3 _LightDir = GetLightDir(ActiveLightIndex);
			GetLightVectorOutput GetLightVector848 = GetLightVectorFunction(ActiveLightIndex, _LightPos, PS_IN.WorldPosition.xyz, _LightType, _LightDir);
			float3 LightVecNorm = normalize(GetLightVector848.Result);
			LambertDiffuseOutput LambertDiffuse823 = LambertDiffuseFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, FlippedNormals, LightVecNorm);
			LightContributionOutput LightContribution397 = LightContributionFunction(ActiveLightIndex, PS_IN.WorldPosition.xyz, GetLightVector848.Result);
			float3 AddTranslucency = (NoTranslucency.xyz + (LightContribution397.Light * LambertDiffuse823.Color));
			float3 Col = float3(1.000000,1.000000,1.000000);
			BlinnSpecularOutput BlinnSpecular966 = BlinnSpecularFunction(ActiveLightIndex, LightVecNorm, FlippedNormals, CamVecNorm, 20.000000, Col.xyz);
			float3 SpecLightIntensity = (BlinnSpecular966.SpecularColor * LightContribution397.Light);
			float3 Diffuse_Spec = ((ClampOpacity * AddTranslucency) + SpecLightIntensity);
			DesaturateColorOutput DesaturateColor664 = DesaturateColorFunction(ActiveLightIndex, SpecLightIntensity);
			float4 Color_Alpha = float4(Diffuse_Spec.x, Diffuse_Spec.y, Diffuse_Spec.z, DesaturateColor664.DesaturateColor);
			IfAmbientLight384 = Color_Alpha;
		}
		float4 ApplyWeight395 = IfAmbientLight384;
		LightLoopTotal11 += ApplyWeight395;
	}



	if (MayaHwFogEnabled) { 
		float fogFactor = (1.0 - PS_IN.FogFactor.x) * MayaHwFogColor.a; 
		VectorConstruct.rgb	= lerp(VectorConstruct.rgb, MayaHwFogColor.rgb, fogFactor); 
	}
	*/

}

}

// -------------------------------------- ShaderPixelP1 --------------------------------------
attribute PIXELDATAP1
{
	float4 outColor0 : COLOR0;
	float4 outColor1 : COLOR1;
};

GLSLShader ShaderPixelP1
{
void main(void)
{
	float4 outColor;
	float InvertSatMask = (1.000000 - clamp(0.000000, 0.0, 1.0));
	float3 Color = float3(0.235294,0.270588,0.501961);
	float3 ReplaceDiffuseWithReflection = (Color.xyz * InvertSatMask);
	float3 NormOp = normalize(PS_IN.Normal.xyz);
	float3 FlippedNormals = mix(-(NormOp), NormOp, float(gl_FrontFacing));
	float ClampOpacity = clamp(1.000000, 0.0, 1.0);
	float3 CameraPosition = viewI[3].xyz;
	float3 CamVec = (CameraPosition - PS_IN.WorldPosition.xyz);
	float3 CamVecNorm = normalize(CamVec);
	float4 LightLoopTotal11 = float4(0,0,0,0);
	for (int ActiveLightIndex = 0; ActiveLightIndex < 3; ++ActiveLightIndex)
	{
		if (ActiveLightIndex >= ClampDynamicLights) {continue;}
		int _LightType = GetLightType(ActiveLightIndex);
		bool IsAmbientLight = (_LightType == 5);
		float4 IfAmbientLight384 = float4(0, 0, 0, 0);
		if (IsAmbientLight)
		{
			float3 _LightColor = GetLightColor(ActiveLightIndex);
			float _LightIntensity = GetLightIntensity(ActiveLightIndex);
			AmbientLightOutput AmbientLight389 = AmbientLightFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, _LightColor, _LightIntensity);
			float3 PreMulAlphaAmbient = (ClampOpacity * (AmbientLight389.LightColor * 1.000000));
			float4 VectorConstruct = float4(PreMulAlphaAmbient.x, PreMulAlphaAmbient.y, PreMulAlphaAmbient.z, 0.000000);
			IfAmbientLight384 = VectorConstruct;
		}
		else
		{
			float3 NoTranslucency = float3(0.000000,0.000000,0.000000);
			float3 _LightPos = GetLightPos(ActiveLightIndex);
			float3 _LightDir = GetLightDir(ActiveLightIndex);
			GetLightVectorOutput GetLightVector848 = GetLightVectorFunction(ActiveLightIndex, _LightPos, PS_IN.WorldPosition.xyz, _LightType, _LightDir);
			float3 LightVecNorm = normalize(GetLightVector848.Result);
			LambertDiffuseOutput LambertDiffuse823 = LambertDiffuseFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, FlippedNormals, LightVecNorm);
			LightContributionOutput LightContribution397 = LightContributionFunction(ActiveLightIndex, PS_IN.WorldPosition.xyz, GetLightVector848.Result);
			float3 AddTranslucency = (NoTranslucency.xyz + (LightContribution397.Light * LambertDiffuse823.Color));
			float3 Col = float3(1.000000,1.000000,1.000000);
			BlinnSpecularOutput BlinnSpecular966 = BlinnSpecularFunction(ActiveLightIndex, LightVecNorm, FlippedNormals, CamVecNorm, 20.000000, Col.xyz);
			float3 SpecLightIntensity = (BlinnSpecular966.SpecularColor * LightContribution397.Light);
			float3 Diffuse_Spec = ((ClampOpacity * AddTranslucency) + SpecLightIntensity);
			DesaturateColorOutput DesaturateColor664 = DesaturateColorFunction(ActiveLightIndex, SpecLightIntensity);
			float4 Color_Alpha = float4(Diffuse_Spec.x, Diffuse_Spec.y, Diffuse_Spec.z, DesaturateColor664.DesaturateColor);
			IfAmbientLight384 = Color_Alpha;
		}
		float4 ApplyWeight395 = IfAmbientLight384;
		LightLoopTotal11 += ApplyWeight395;
	}
	float3 NoReflection = float3(0.000000,0.000000,0.000000);
	float3 ReflectXmask = (NoReflection.xyz * 0.000000);
	float3 DefaultEmissiveColor = float3(0.000000,0.000000,0.000000);
	float3 DefaultIBLColor = float3(0.000000,0.000000,0.000000);
	float3 PreMultipliedAlpha = (ClampOpacity * (DefaultEmissiveColor.xyz + DefaultIBLColor.xyz));
	float3 AddReflection = (ReflectXmask + PreMultipliedAlpha);
	DesaturateColorOutput DesaturateColor363 = DesaturateColorFunction(ReflectXmask);
	float OpacityAndReflection = (ClampOpacity + DesaturateColor363.DesaturateColor);
	float4 TotalAmbientAndOpacity = float4(AddReflection.x, AddReflection.y, AddReflection.z, OpacityAndReflection);
	float4 LightLoopAndAfterLoop = (LightLoopTotal11 + TotalAmbientAndOpacity);
	float SatOp = clamp(LightLoopAndAfterLoop.w, 0.0, 1.0);
	float4 VectorConstruct = float4(LightLoopAndAfterLoop.xyz.x, LightLoopAndAfterLoop.xyz.y, LightLoopAndAfterLoop.xyz.z, SatOp);
	outColor = VectorConstruct;
	DepthPeelOutput DepthPeel = DepthPeelFunc(PS_IN.WorldPosition.xyz, view, viewPrj);
	outColor0 = outColor;
	outColor1 = DepthPeel.LinearDepth;
}

}

// -------------------------------------- ShaderPixelP2 --------------------------------------
attribute PIXELDATAP2
{
	float4 outColor0 : COLOR0;
	float4 outColor1 : COLOR1;
};

GLSLShader ShaderPixelP2
{
void main(void)
{
	float4 outColor;
	float InvertSatMask = (1.000000 - clamp(0.000000, 0.0, 1.0));
	float3 Color = float3(0.235294,0.270588,0.501961);
	float3 ReplaceDiffuseWithReflection = (Color.xyz * InvertSatMask);
	float3 NormOp = normalize(PS_IN.Normal.xyz);
	float3 FlippedNormals = mix(-(NormOp), NormOp, float(gl_FrontFacing));
	float ClampOpacity = clamp(1.000000, 0.0, 1.0);
	float3 CameraPosition = viewI[3].xyz;
	float3 CamVec = (CameraPosition - PS_IN.WorldPosition.xyz);
	float3 CamVecNorm = normalize(CamVec);
	float4 LightLoopTotal11 = float4(0,0,0,0);
	for (int ActiveLightIndex = 0; ActiveLightIndex < 3; ++ActiveLightIndex)
	{
		if (ActiveLightIndex >= ClampDynamicLights) {continue;}
		int _LightType = GetLightType(ActiveLightIndex);
		bool IsAmbientLight = (_LightType == 5);
		float4 IfAmbientLight384 = float4(0, 0, 0, 0);
		if (IsAmbientLight)
		{
			float3 _LightColor = GetLightColor(ActiveLightIndex);
			float _LightIntensity = GetLightIntensity(ActiveLightIndex);
			AmbientLightOutput AmbientLight389 = AmbientLightFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, _LightColor, _LightIntensity);
			float3 PreMulAlphaAmbient = (ClampOpacity * (AmbientLight389.LightColor * 1.000000));
			float4 VectorConstruct = float4(PreMulAlphaAmbient.x, PreMulAlphaAmbient.y, PreMulAlphaAmbient.z, 0.000000);
			IfAmbientLight384 = VectorConstruct;
		}
		else
		{
			float3 NoTranslucency = float3(0.000000,0.000000,0.000000);
			float3 _LightPos = GetLightPos(ActiveLightIndex);
			float3 _LightDir = GetLightDir(ActiveLightIndex);
			GetLightVectorOutput GetLightVector848 = GetLightVectorFunction(ActiveLightIndex, _LightPos, PS_IN.WorldPosition.xyz, _LightType, _LightDir);
			float3 LightVecNorm = normalize(GetLightVector848.Result);
			LambertDiffuseOutput LambertDiffuse823 = LambertDiffuseFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, FlippedNormals, LightVecNorm);
			LightContributionOutput LightContribution397 = LightContributionFunction(ActiveLightIndex, PS_IN.WorldPosition.xyz, GetLightVector848.Result);
			float3 AddTranslucency = (NoTranslucency.xyz + (LightContribution397.Light * LambertDiffuse823.Color));
			float3 Col = float3(1.000000,1.000000,1.000000);
			BlinnSpecularOutput BlinnSpecular966 = BlinnSpecularFunction(ActiveLightIndex, LightVecNorm, FlippedNormals, CamVecNorm, 20.000000, Col.xyz);
			float3 SpecLightIntensity = (BlinnSpecular966.SpecularColor * LightContribution397.Light);
			float3 Diffuse_Spec = ((ClampOpacity * AddTranslucency) + SpecLightIntensity);
			DesaturateColorOutput DesaturateColor664 = DesaturateColorFunction(ActiveLightIndex, SpecLightIntensity);
			float4 Color_Alpha = float4(Diffuse_Spec.x, Diffuse_Spec.y, Diffuse_Spec.z, DesaturateColor664.DesaturateColor);
			IfAmbientLight384 = Color_Alpha;
		}
		float4 ApplyWeight395 = IfAmbientLight384;
		LightLoopTotal11 += ApplyWeight395;
	}
	float3 NoReflection = float3(0.000000,0.000000,0.000000);
	float3 ReflectXmask = (NoReflection.xyz * 0.000000);
	float3 DefaultEmissiveColor = float3(0.000000,0.000000,0.000000);
	float3 DefaultIBLColor = float3(0.000000,0.000000,0.000000);
	float3 PreMultipliedAlpha = (ClampOpacity * (DefaultEmissiveColor.xyz + DefaultIBLColor.xyz));
	float3 AddReflection = (ReflectXmask + PreMultipliedAlpha);
	DesaturateColorOutput DesaturateColor363 = DesaturateColorFunction(ReflectXmask);
	float OpacityAndReflection = (ClampOpacity + DesaturateColor363.DesaturateColor);
	float4 TotalAmbientAndOpacity = float4(AddReflection.x, AddReflection.y, AddReflection.z, OpacityAndReflection);
	float4 LightLoopAndAfterLoop = (LightLoopTotal11 + TotalAmbientAndOpacity);
	float SatOp = clamp(LightLoopAndAfterLoop.w, 0.0, 1.0);
	float4 VectorConstruct = float4(LightLoopAndAfterLoop.xyz.x, LightLoopAndAfterLoop.xyz.y, LightLoopAndAfterLoop.xyz.z, SatOp);
	outColor = VectorConstruct;
	DepthPeelOutput DepthPeel = DepthPeelFunc(PS_IN.WorldPosition.xyz, view, viewPrj);
	outColor0 = outColor;
	outColor1 = ((outColor0.w > 0.001f ? float4(1.0f, 1.0f, 1.0f, 1.0f) : float4(0.0f, 0.0f, 0.0f, 0.0f)) * DepthPeel.Peel);
}

}

// -------------------------------------- ShaderPixelP3 --------------------------------------
attribute PIXELDATAP3
{
	float4 outColor0 : COLOR0;
	float4 outColor1 : COLOR1;
};

GLSLShader ShaderPixelP3
{
void main(void)
{
	float4 outColor;
	float InvertSatMask = (1.000000 - clamp(0.000000, 0.0, 1.0));
	float3 Color = float3(0.235294,0.270588,0.501961);
	float3 ReplaceDiffuseWithReflection = (Color.xyz * InvertSatMask);
	float3 NormOp = normalize(PS_IN.Normal.xyz);
	float3 FlippedNormals = mix(-(NormOp), NormOp, float(gl_FrontFacing));
	float ClampOpacity = clamp(1.000000, 0.0, 1.0);
	float3 CameraPosition = viewI[3].xyz;
	float3 CamVec = (CameraPosition - PS_IN.WorldPosition.xyz);
	float3 CamVecNorm = normalize(CamVec);
	float4 LightLoopTotal11 = float4(0,0,0,0);
	for (int ActiveLightIndex = 0; ActiveLightIndex < 3; ++ActiveLightIndex)
	{
		if (ActiveLightIndex >= ClampDynamicLights) {continue;}
		int _LightType = GetLightType(ActiveLightIndex);
		bool IsAmbientLight = (_LightType == 5);
		float4 IfAmbientLight384 = float4(0, 0, 0, 0);
		if (IsAmbientLight)
		{
			float3 _LightColor = GetLightColor(ActiveLightIndex);
			float _LightIntensity = GetLightIntensity(ActiveLightIndex);
			AmbientLightOutput AmbientLight389 = AmbientLightFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, _LightColor, _LightIntensity);
			float3 PreMulAlphaAmbient = (ClampOpacity * (AmbientLight389.LightColor * 1.000000));
			float4 VectorConstruct = float4(PreMulAlphaAmbient.x, PreMulAlphaAmbient.y, PreMulAlphaAmbient.z, 0.000000);
			IfAmbientLight384 = VectorConstruct;
		}
		else
		{
			float3 NoTranslucency = float3(0.000000,0.000000,0.000000);
			float3 _LightPos = GetLightPos(ActiveLightIndex);
			float3 _LightDir = GetLightDir(ActiveLightIndex);
			GetLightVectorOutput GetLightVector848 = GetLightVectorFunction(ActiveLightIndex, _LightPos, PS_IN.WorldPosition.xyz, _LightType, _LightDir);
			float3 LightVecNorm = normalize(GetLightVector848.Result);
			LambertDiffuseOutput LambertDiffuse823 = LambertDiffuseFunction(ActiveLightIndex, ReplaceDiffuseWithReflection, FlippedNormals, LightVecNorm);
			LightContributionOutput LightContribution397 = LightContributionFunction(ActiveLightIndex, PS_IN.WorldPosition.xyz, GetLightVector848.Result);
			float3 AddTranslucency = (NoTranslucency.xyz + (LightContribution397.Light * LambertDiffuse823.Color));
			float3 Col = float3(1.000000,1.000000,1.000000);
			BlinnSpecularOutput BlinnSpecular966 = BlinnSpecularFunction(ActiveLightIndex, LightVecNorm, FlippedNormals, CamVecNorm, 20.000000, Col.xyz);
			float3 SpecLightIntensity = (BlinnSpecular966.SpecularColor * LightContribution397.Light);
			float3 Diffuse_Spec = ((ClampOpacity * AddTranslucency) + SpecLightIntensity);
			DesaturateColorOutput DesaturateColor664 = DesaturateColorFunction(ActiveLightIndex, SpecLightIntensity);
			float4 Color_Alpha = float4(Diffuse_Spec.x, Diffuse_Spec.y, Diffuse_Spec.z, DesaturateColor664.DesaturateColor);
			IfAmbientLight384 = Color_Alpha;
		}
		float4 ApplyWeight395 = IfAmbientLight384;
		LightLoopTotal11 += ApplyWeight395;
	}
	float3 NoReflection = float3(0.000000,0.000000,0.000000);
	float3 ReflectXmask = (NoReflection.xyz * 0.000000);
	float3 DefaultEmissiveColor = float3(0.000000,0.000000,0.000000);
	float3 DefaultIBLColor = float3(0.000000,0.000000,0.000000);
	float3 PreMultipliedAlpha = (ClampOpacity * (DefaultEmissiveColor.xyz + DefaultIBLColor.xyz));
	float3 AddReflection = (ReflectXmask + PreMultipliedAlpha);
	DesaturateColorOutput DesaturateColor363 = DesaturateColorFunction(ReflectXmask);
	float OpacityAndReflection = (ClampOpacity + DesaturateColor363.DesaturateColor);
	float4 TotalAmbientAndOpacity = float4(AddReflection.x, AddReflection.y, AddReflection.z, OpacityAndReflection);
	float4 LightLoopAndAfterLoop = (LightLoopTotal11 + TotalAmbientAndOpacity);
	float SatOp = clamp(LightLoopAndAfterLoop.w, 0.0, 1.0);
	float4 VectorConstruct = float4(LightLoopAndAfterLoop.xyz.x, LightLoopAndAfterLoop.xyz.y, LightLoopAndAfterLoop.xyz.z, SatOp);
	outColor = VectorConstruct;
	outColor0 = outColor;
	outColor1 = (outColor0.w > 0.001f ? float4(1.0f, 1.0f, 1.0f, 1.0f) : float4(0.0f, 0.0f, 0.0f, 0.0f));
}

}

// -------------------------------------- technique T0 ---------------------------------------
technique T0
<
	string transparency = "opaque";
	string supportsAdvancedTransparency = "true";
>
{
	pass P0
	<
		string drawContext = "colorPass";
	>
	{
		VertexShader (in APPDATA, out SHADERDATA VS_OUT) = { Common_Funcs, VertexShader_Funcs, ShaderVertex};
		PixelShader (in SHADERDATA PS_IN, out PIXELDATA) = { Common_Funcs, PixelShader_Funcs, ShaderPixel};
	}

	pass P1
	<
		string drawContext = "transparentPeel";
	>
	{
		VertexShader (in APPDATA, out SHADERDATA VS_OUT) = { Common_Funcs, VertexShader_Funcs, ShaderVertex};
		PixelShader (in SHADERDATA PS_IN, out PIXELDATAP1) = { Common_Funcs, PixelShader_Funcs, ShaderPixelP1};
	}

	pass P2
	<
		string drawContext = "transparentPeelAndAvg";
	>
	{
		VertexShader (in APPDATA, out SHADERDATA VS_OUT) = { Common_Funcs, VertexShader_Funcs, ShaderVertex};
		PixelShader (in SHADERDATA PS_IN, out PIXELDATAP2) = { Common_Funcs, PixelShader_Funcs, ShaderPixelP2};
	}

	pass P3
	<
		string drawContext = "transparentWeightedAvg";
	>
	{
		VertexShader (in APPDATA, out SHADERDATA VS_OUT) = { Common_Funcs, VertexShader_Funcs, ShaderVertex};
		PixelShader (in SHADERDATA PS_IN, out PIXELDATAP3) = { Common_Funcs, PixelShader_Funcs, ShaderPixelP3};
	}

}

