
// transform object vertices to world-space:
uniform mat4 gWorldXf : World < string UIWidget="None"; >;

// transform object normals, tangents, & binormals to world-space:
uniform mat4 gWorldITXf : WorldInverseTranspose < string UIWidget="None"; >;

// transform object vertices to view space and project them in perspective:
uniform mat4 gWvpXf : WorldViewProjection < string UIWidget="None"; >;

// provide tranform from "view" or "eye" coords back to world-space:
uniform mat4 gViewIXf : ViewInverse < string UIWidget="None"; >;


/*** TWEAKABLES *********************************************/
uniform mat4 world : World < string UIWidget = "None"; >;
uniform mat4 worldI : WorldInverse < string UIWidget = "None"; >;
uniform mat4 view : View < string UIWidget = "None"; >;
uniform mat4 worldLocale : WorldLocaleOrigin < string UIWidget = "None"; >;
uniform mat4 proj : Projection < string UIWidget = "None"; >;
uniform mat4 viewI : ViewInverse < string UIWidget = "None"; >;
uniform mat4 worldview : WorldView < string UIWidget = "None"; >;
uniform mat4 worldviewprojI : WorldViewProjectionInverse < string UIWidget = "None"; >;

uniform float cutoffOuter
<
    string UIWidget = "slider";
    float UIMin = -4.0;
    float UIMax = 4.0;
    float UIStep = 0.01;
    string UIName = "Outer Cutoff";
    string UIGroup = "Lantern Colors";
> = 0.911;

uniform float cutoffMiddle
<
    string UIWidget = "slider";
    float UIMin = -4.0;
    float UIMax = 4.0;
    float UIStep = 0.01;
    string UIName = "Middle Cutoff";
    string UIGroup = "Lantern Colors";
> = 0.5;

uniform float softness
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Edge Softness";
    string UIGroup = "Lantern Colors";
> = 0.031;

uniform float eyeDirFudge
<
    string UIWidget = "slider";
    float UIMin = -1.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Fudge Eye Direction";
    string UIGroup = "Fudge Factors";
> = 0.1;

uniform float darkenFudge
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Fudge Darken";
    string UIGroup = "Fudge Factors";
> = 0.17;

uniform float lightenFudge
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Fudge Lighten";
    string UIGroup = "Fudge Factors";
> = 0.17;

uniform float fudgeHotSpot
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Cuttoff to See HotSpot";
    string UIGroup = "Fudge Factors";
> = 0.1;

uniform float fudgePosition
<
    string UIWidget = "slider";
    float UIMin = -1.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Distance to Halfway";
    string UIGroup = "Fudge Factors";
> = 0.1;

uniform float eyeSpreadFudge
<
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Softness Decrease with Eye Direction";
    string UIGroup = "Fudge Factors";
> = 1.0;

uniform float fudgeNormalHeight
<
    string UIWidget = "slider";
    float UIMin = -1.00;
    float UIMax = 1.0;
    float UIStep = 0.01;
    string UIName = "Distance to Halfway";
    string UIGroup = "Fudge Factors";
> = 1.0;

uniform float brightSpot
<
    string UIWidget = "slider";
    float UIMin = 0.00;
    float UIMax = 300.0;
    float UIStep = 0.01;
    string UIName = "Bright Spot Power";
    string UIGroup = "Lantern Colors";
> = 83.297;

uniform vec4 hotColor
<
    string UIName = "Hotspot Color";
    string UIWidget = "Color";
    string UIGroup = "Lantern Colors";
> = {1.0, 0.84, 0.35, 1.0f};

uniform vec4 middleColor
<
    string UIName = "Middle Color";
    string UIWidget = "Color";
    string UIGroup = "Lantern Colors";
> = {0.82, 0.54, 0.0, 1.0f};

uniform vec4 outerColor
<
    string UIName = "Outer Color";
    string UIWidget = "Color";
    string UIGroup = "Lantern Colors";
> = {0.58, 0.0, 0.0, 1.0f};


uniform texture2D diffuseColorTex <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Diffuse Texture";
    string UIGroup = "Base Color";
>;

uniform sampler2D diffuseSampler
    = sampler_state {
    Texture = <diffuseColorTex>;
};

uniform texture2D insideMask <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Inside Mask";
    string UIGroup = "Base Color";
>;

uniform sampler2D insideSampler
    = sampler_state {
    Texture = <insideMask>;
};

uniform bool use_normal
#if OGSFX
<
    string UIName = "Use Normal Map";
    string UIGroup = "Base Color";
>
#endif
    = 0;

uniform texture2D normalMap <
    string ResourceName = "";
    string ResourceType = "2D";
    // string UIWidget = "None";
    string UIDesc = "Normal Map";
    string UIGroup = "Base Color";
>;

uniform sampler2D normalSampler
    = sampler_state {
    Texture = <normalMap>;
};


attribute appdata {
    vec3 Position    : POSITION;
    vec2 UV        : TEXCOORD0;
    vec3 Normal    : NORMAL;
    vec4 Tangent : TANGENT;
};

/* data passed from vertex shader to pixel shader */
attribute cellVertexOutput {
    vec3 WorldNormal    : TEXCOORD1;
    vec3 WorldEyeVec    : TEXCOORD2;
    vec3 fNormal : TEXCOORD3;
    vec4 fTangent : TEXCOORD6;
    vec2 fUV : TEXCOORD4;
    vec3 fPos : TEXCOORD5;
};

/* data passed from vertex shader to pixel shader */
attribute cellPixelInput {
    vec3 WorldNormal    : TEXCOORD1;
    vec3 WorldEyeVec    : TEXCOORD2;
    vec3 fNormal : TEXCOORD3;
    vec4 fTangent : TEXCOORD6;
    vec2 fUV : TEXCOORD4;
    vec3 fPos : TEXCOORD5;
};

/* data output by the fragment shader */
attribute pixelOut 
{
    vec4 colorOut:COLOR0;
}

GLSLShader VS
{
	void main(void)
	{
        vec4 Po = vec4(Position.xyz,1);
        vec3 Pw = (gWorldXf*Po).xyz;
        WorldEyeVec = normalize(gViewIXf[3].xyz - Pw);
        fUV = vec2(UV.x, 1-UV.y);
        WorldNormal = (gWorldITXf * vec4(Normal,1.0)).xyz;
        fPos = Position;
        fNormal = Normal;
        fTangent = Tangent;
        gl_Position = gWvpXf * Po;
	}
}


GLSLShader FS
{

	float calc_alpha( float softness, float cutoff, float cos );
    float blendOverlay(float base, float blend);
    vec4 blendOverlay(vec4 base, vec4 blend);
    vec4 blendOverlay(vec4 base, vec4 blend, float opacity);
    vec3 TangentWorldConvertFunction(float TangentDirection, vec3 Normal, vec3 Tangent, vec3 Vector);

	void main(void)
	{
        vec3 worldNormalFrag = WorldNormal;
        vec3 NormOp = normalize(fNormal);
        if (use_normal)
        {
            vec3 tangent = normalize(fTangent).xyz;
            vec4 sample = texture(normalSampler, fUV);
            vec3 ExpandRange = sample.xyz*2.0 - 1.0;
            vec3 VectorConstruct = vec3(fudgeNormalHeight, fudgeNormalHeight, 1.0);
            vec3 NormalMapH = (VectorConstruct.xyz * ExpandRange);
            vec3 TangentWorldConvert2066 = TangentWorldConvertFunction(1.0, NormOp, tangent, NormalMapH);
            worldNormalFrag = normalize(TangentWorldConvert2066);
        }

        vec4 base_color = texture2D(diffuseSampler, fUV) - vec4(darkenFudge);
		float cos = abs(dot( worldNormalFrag, normalize(WorldEyeVec - vec3(0.0, eyeDirFudge, 0.0)) ));
		float alphaOuter = calc_alpha( softness + eyeSpreadFudge * cos, cutoffOuter, cos );
        float alphaMiddle = calc_alpha( softness + eyeSpreadFudge * cos, cutoffMiddle, cos );
		vec4 gradientOuter = outerColor * alphaOuter;
        vec4 gradientMiddle = alphaMiddle * middleColor;

        float dodgeLerpFactor = 1.0;
        if (base_color.g < fudgeHotSpot) {
            dodgeLerpFactor = base_color.g;
        }
        vec4 colorDodge = lerp( base_color, saturate(hotColor + base_color), dodgeLerpFactor);

        vec4 colorOverlay = blendOverlay(base_color, gradientOuter, base_color.g);
        colorOverlay = blendOverlay(colorOverlay, gradientMiddle, base_color.g);
        if (length(texture2D(insideSampler, fUV).rgb) < 0.1) {
            colorOut = base_color + vec4(lightenFudge);
        } else {
            colorOut = lerp(colorOverlay, colorDodge, pow(cos, brightSpot));
        }
	}

	float calc_alpha( float softness, float cutoff, float cos )
	{
	    float lower_bound = cutoff - softness;
	    float upper_bound = cutoff + softness;
	    float result_alpha = 0;
	    if (cos < lower_bound) {
	        result_alpha = 0.0;
	    } else {
	        if (cos > upper_bound) {
	            result_alpha = 1.0;
	        } else {
	            result_alpha = ( cos - lower_bound ) / ( 2 * softness );
	        }
	    }
	    return result_alpha;
	}

    vec4 blendOverlay(vec4 base, vec4 blend, float opacity) {
        return (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));
    }

    vec4 blendOverlay(vec4 base, vec4 blend) {
        return vec4(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b), 1.0);
    }

    float blendOverlay(float base, float blend) {
        return base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));
    }

    vec3 TangentWorldConvertFunction(float TangentDirection, vec3 Normal, vec3 Tangent, vec3 Vector)
    {
        vec3 Bn = (TangentDirection * cross(Normal, Tangent));
        mat3 toWorld = mat3(Tangent, Bn, Normal);
        return (toWorld * Vector);
    }
}

technique main
{
	pass light_color
	<
		string drawContext = "colorPass";
	>
	{
        VertexShader (in appdata, out cellVertexOutput) = VS;
        PixelShader (in cellVertexOutput, out pixelOut) = FS;
	}

}

